{"meta":{"title":"Ryan Shang","subtitle":"生死看淡，不服就干","description":"前端渣渣一枚，热爱科技，热爱搞事请","author":"Ryan Shang","url":"http://shangliushuai.cn"},"pages":[{"title":"","date":"2019-12-24T00:13:45.591Z","updated":"2019-12-24T00:13:45.591Z","comments":true,"path":"404.html","permalink":"http://shangliushuai.cn/404.html","excerpt":"","text":""},{"title":"分类","date":"2017-10-10T11:31:11.000Z","updated":"2019-12-24T00:13:45.619Z","comments":true,"path":"categories/index.html","permalink":"http://shangliushuai.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-10-10T11:24:29.000Z","updated":"2019-12-24T00:13:45.620Z","comments":true,"path":"tags/index.html","permalink":"http://shangliushuai.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Node后台开发中使用TypeOrm遇到的问题","slug":"Node后台开发中使用TypeOrm遇到的问题","date":"2020-01-16T16:00:00.000Z","updated":"2020-01-27T10:04:47.404Z","comments":true,"path":"2020/01/17/Node后台开发中使用TypeOrm遇到的问题/","link":"","permalink":"http://shangliushuai.cn/2020/01/17/Node后台开发中使用TypeOrm遇到的问题/","excerpt":"","text":"前言最近项目中使用Node开发，Nest.js作为框架，TypeOrm连接数据库，期间遇到一些坑，这里记录一下。 问题1. 插入数据之后返回的ID集合，ID相同在TypeOrm插入数据库操作的返回结果中，identifiers字段会是插入数据的id集合，预期情况应该是这样的： 1234[ &#123; id: 1 &#125;, &#123; id: 2 &#125;] 但实际开发中发现是这样： 1234[ &#123; id: 1 &#125;, &#123; id: 1 &#125;] 因为，业务中后面要根据返回的ID值给其他数据做关联，所以返回相同ID会造成异常。 查看了github，有相关issue，但是一直处于open状态：https://github.com/typeorm/typeorm/issues/2131。 最后临时方案是采用在后面操作中，用id+数组index的方式，拼出id。 2. JavaScript对数据库中int和bigint的区别对待刚开始开发中，线下测试数据库id字段采用int，数据库SELECT操作返回的结果是Number，但是使用bigint，数据库返回的为String，初步猜想是因为bigint的值范围会超过Number，所以采用String。 但是这样会对我们业务产生巨大影戏那个，一方面，DTO校验会无法通过，另一方面，问题1中的业务逻辑会受影响。 经过查找各方文档，解决方案是在数据库连接配置中配置： 1\"supportBigNumbers\": false 可以配置这个的原因是我们的业务ID距离Number的上线远远达不到，所以可以用这种方式让 bigint也返回Number。 但是这样配置，TypeOrm插入操作的返回值中的identifiers字段中的id还是String，所以问题1中的处理方式也要对String进行parseInt操作。 3. 数据库版本区别问题测试上线时，发现功能无法使用，测试环境正常，经过线上测试库分别连接测试定位后，发现还是identifiers，返回的id为undefined。 线上数据库版本为5.6，测试数据库版本为5.7。TypeOrm的insert()生成的SQL会有插入id的操作，值为默认值，5.7中可以正常插入，5.6中会插入异常，返回值为undefined，导致报错异常事务回滚。 经过测试，插入数据库操作时，id赋值为null可以解决，后更新上线，因为部署问题无法上线，等待后续上线后检验时候还存在问题。 4. TypeOrm数据库配置问题导致编译慢项目刚开始开发时，每次本地编辑十分慢，查找文档等发现问题是配置原因，刚开始数据库的entities配置项是这样的： 1\"entities\": [\"src/entities/*.ts\"] 编译时候应该是先会把ts文件编译成js，所以耗时比较久，后改成 1\"entities\": [\"output/nodeapp/kid-mis-backend/src/entities/*.js\"] 直接使用编译后的js文件，编译速度大大提升。 总结后端开发和前端开发有很大的区别，各种解决问题思路不同，后端部分还有很多需要我学习的地方。","categories":[{"name":"后端","slug":"后端","permalink":"http://shangliushuai.cn/categories/后端/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://shangliushuai.cn/tags/Node/"},{"name":"TypeOrm","slug":"TypeOrm","permalink":"http://shangliushuai.cn/tags/TypeOrm/"}]},{"title":"个人终端环境配置（zsh）","slug":"个人终端环境配置（zsh）","date":"2020-01-04T16:00:00.000Z","updated":"2020-01-27T10:04:31.757Z","comments":true,"path":"2020/01/05/个人终端环境配置（zsh）/","link":"","permalink":"http://shangliushuai.cn/2020/01/05/个人终端环境配置（zsh）/","excerpt":"","text":"个人使用的开发Mac，很早就用别人给的教程配置好了Zsh，使用一直很舒服，这次在自己的deepin上配置一次，这里做个简单记录。 安装清单 名称 备注 链接 zsh shell的一种 https://www.zsh.org/ oh-my-zsh zsh的配置工具 https://ohmyz.sh/ zsh-autosuggestions 命令自动补全插件 https://github.com/zsh-users/zsh-autosuggestions zsh-syntax-highlighting 命令高亮插件 https://github.com/zsh-users/zsh-syntax-highlighting Powerline 个人用主题的字体（不用会乱码） https://github.com/powerline/fonts iTerm2 Mac下一个推荐的终端 http://iterm2.com/ 安装过程1. 安装zsh各家平台的包管理工具都可以安装。 2. 安装oh-my-zsh1sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" 推荐使用curl方式，会修改shell默认为zsh。 3. 修改配置编辑.zshrc，找到主题，修改为： 1ZSH_THEME=&quot;agnoster&quot; 重启终端，会更换主题。更换后会发现有部分乱码。 4. 解决字体乱码问题安装powerline： 12345678# clonegit clone https://github.com/powerline/fonts.git --depth=1# installcd fonts./install.sh# clean-up a bitcd ..rm -rf fonts 配置字体为：Meslo LG M for Powerline 卸载执行: 1./uninstall.sh 5. 安装插件12git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestionsgit clone https://github.com/zsh-users/zsh-syntax-highlighting $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting 安装完成后，修改.zshrc 12345plugins=( zsh-autosuggestions zsh--syntax-highlighting git) 重启终端。 6. 其他Mac上的配色方案可以用solarized 1234567891011121314151617# git下Solarized 的源码git clone git://github.com/altercation/solarized.git# 进入文件夹cd solarized/vim-colors-solarized/colors#下面可能要管理员权限sudo mkdir -p ~/.vim/colorssudo cp solarized.vim ~/.vim/colors/# 创建.vimrc文件sudo vim ~/.vimrc# 把下面这三行复制进去syntax enableset background=darkcolorscheme solarized","categories":[{"name":"工具","slug":"工具","permalink":"http://shangliushuai.cn/categories/工具/"}],"tags":[{"name":"终端","slug":"终端","permalink":"http://shangliushuai.cn/tags/终端/"},{"name":"Zsh","slug":"Zsh","permalink":"http://shangliushuai.cn/tags/Zsh/"}]},{"title":"记录一次个人git事故","slug":"记录一次个人git事故","date":"2019-12-24T16:00:00.000Z","updated":"2020-01-27T10:04:23.986Z","comments":true,"path":"2019/12/25/记录一次个人git事故/","link":"","permalink":"http://shangliushuai.cn/2019/12/25/记录一次个人git事故/","excerpt":"","text":"今天圣诞节，在工作时侯，出现了一个有意思的意外情况，这里做下记录。 事情经过一个比较大的需求，每天都保持了一次个人开发分支提交。今天发现有4次提交没有合并到主开发分支，于是动手合并，合并记如下： 123456789101112131410262 gco dev10263 git pull10264 git log10265 gco feature/my-dev-branch10266 git rebase dev10267 git rebase -i HEAD~410268 git log10269 git rebase -i HEAD~110270 git log10271 git push -f10272 gco dev10273 git merge feature/my-dev-branch10274 git push10275 git log 我们部门合并到主开发分支前，要求合并下commit记录，按照以往的流程是没有问题的。 但是在执行git rebase -i HEAD~4合并commit记录时候，可能最近用vim写文件删除操作较多，顺手把三个记录直接使用vim快捷操作dd删除并快速保存，并不是修改提交记录前的标签。当时并没有注意，执行git push -f后，发现VSCode中打开的文件显示已删除，于是才发现问题。 事情后果如果不处理，相当于三天工作量打水漂，代码需要重写，严重影响排期。 解决过程第一反应是执行git log查看已经提交的记录是否存在，存在的话使用git reset配合记录的哈希值可以恢复到那次提交记录。结果当然相关 的commit 记录已经被删除。 如果可以找到丢失的commit记录，应该就可以快速找回丢失的代码。 于是去git官网和搜索引擎下找了commit记录丢失后的相关命令，发现这个命令： 1git reflog 返回结果里面包含本队分支的操作记录，包括提交、切换分支等，在其中找到对应提交的哈希值，使用git reset命令成功回到最新一次提交，找回所有代码。 事后反思 对git操作一定要谨慎 每做一步操作，及时检查，不能认为自己经常操作的步骤就一定没有问题 多了解git的命令，有助于出错后及时拨乱反正","categories":[{"name":"工具","slug":"工具","permalink":"http://shangliushuai.cn/categories/工具/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://shangliushuai.cn/tags/Git/"}]},{"title":"Linux任务脚本","slug":"Linux任务脚本","date":"2019-12-21T16:00:00.000Z","updated":"2020-01-27T10:04:15.891Z","comments":true,"path":"2019/12/22/Linux任务脚本/","link":"","permalink":"http://shangliushuai.cn/2019/12/22/Linux任务脚本/","excerpt":"","text":"这几周在研究安卓手机的Linux Deploy和FRP内网穿透，每次启动关闭重启都要手动执行一些命令，于是想到用shell脚本去控制，稍稍研究了下，写了几个脚本，这里做下记录，以Frpc进程为例，假设Frp编译后的文件夹路径为/home/user/frp start.sh 1234567891011NAME=frpcNAME_OUT=\"$&#123;NAME^&#125;\"DIR=/home/user/frpPID=$(ps -e | grep $NAME | awk &#123;'print $1'&#125;)if [[ $PID == \"\" ]]then nohup $DIR/$NAME -c $DIR/$NAME.ini &gt; $DIR/nohup.out 2&gt;&amp;1 &amp; echo \"Start $NAME_OUT Success\"else echo \"$NAME_OUT is already running!\"fi stop.sh 1234567891011NAME=frpcNAME_OUT=\"$&#123;NAME^&#125;\"DIR=/home/user/frpPID=$(ps -e | grep $NAME | awk &#123;'print $1'&#125;)if [[ $PID == \"\" ]]then echo \"$NAME_OUT is not running!\"else sudo kill -9 $PID echo \"Stop $NAME_OUT Success!\"fi restart.sh 12345678910111213NAME=frpcNAME_OUT=\"$&#123;NAME^&#125;\"DIR=/home/user/frpPID=$(ps -e | grep $NAME | awk &#123;'print $1'&#125;)if [[ $PID == \"\" ]]then nohup $DIR/$NAME -c $DIR/$NAME.ini &gt; $DIR/nohup.out 2&gt;&amp;1 &amp; echo \"Start $NAME_OUT Success!\"else sudo kill -9 $PID nohup $DIR/$NAME -c $DIR/$NAME.ini &gt; $DIR/nohup.out 2&gt;&amp;1 &amp; echo \"Restart $NAME_OUT Success!\"fi 现在还有几个问题需要后面关注下： awk后面参数，如果是双引号，则会又问题，单引号和双引号应该是有区别的，需要关注下有区别的原因 三个脚本其实包含大量重复内容，后面考虑合成一个脚本，利用参数方式区分执行命令 需要了解下Linux中比较常见的几个服务管理工具，了解下原理，例如service command","categories":[{"name":"Linux","slug":"Linux","permalink":"http://shangliushuai.cn/categories/Linux/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://shangliushuai.cn/tags/Ubuntu/"},{"name":"CentOS","slug":"CentOS","permalink":"http://shangliushuai.cn/tags/CentOS/"}]},{"title":"个人电脑设备常用软件整理","slug":"个人电脑设备常用软件整理","date":"2019-12-14T16:00:00.000Z","updated":"2020-01-27T10:04:07.509Z","comments":true,"path":"2019/12/15/个人电脑设备常用软件整理/","link":"","permalink":"http://shangliushuai.cn/2019/12/15/个人电脑设备常用软件整理/","excerpt":"","text":"整理记录下个人常用的各平台的应用软件： 1. 日常工具类 名称 备注 网址 Windows Mac Linux Motrix 下载工具 https://motrix.app/zh-CN/ ✔ ✔ ✔ Xmind 思维导图 https://www.xmind.net/ ✔ ✔ ✔ draw.io 流程图工具 https://www.draw.io/ ✔ ✔ ✔ Gas Mask host管理工具 https://github.com/2ndalpha/gasmask ✔ New File Menu Free 新建文件工具 App Store ✔ Go2Shell 在访达当前路径打开终端 https://zipzapmac.com/Go2Shell ✔ Hyper 终端 https://hyper.is/ ✔ ✔ ✔ oh-my-zsh 终端配置工具 https://ohmyz.sh/ ✔ ✔ Windows Terminal 终端 https://github.com/microsoft/terminal ✔ Listary 快捷启动工具 https://www.listary.com/ ✔ Alfred 快捷键效率工具 https://www.alfredapp.com/ ✔ Typora Markdown编辑器 https://www.typora.io/ ✔ ✔ ✔ 2. 影音娱乐类 名称 备注 网址 Windows Mac Linux listen1 吃饭工具0.0 https://listen1.github.io/listen1/ ✔ ✔ ✔ HandBrake 视频转码编辑软件 https://handbrake.fr/ ✔ ✔ ✔ Potplayer 视频播放器 https://potplayer.daum.net/ ✔ IINA 视频播放器 https://iina.io/ ✔ VLC Media Player 视频播放器 https://www.videolan.org/vlc/index.zh.html ✔ ✔ ✔ 3. 编程开发类 名称 备注 网址 Windows Mac Linux VSCode 吃饭工具0.0 https://code.visualstudio.com/ ✔ ✔ ✔ Chrome Google旗下浏览器 https://www.google.com/intl/zh-CN/chrome/ ✔ ✔ ✔ Edge 微软旗下浏览器 https://www.microsoft.com/en-us/edge ✔ ✔ Postman 请求调试软件 https://www.getpostman.com/ ✔ ✔ ✔ WSL2 Windows下Linux子系统 https://docs.microsoft.com/en-us/windows/wsl/wsl2-install ✔","categories":[{"name":"工具","slug":"工具","permalink":"http://shangliushuai.cn/categories/工具/"},{"name":"Linux","slug":"工具/Linux","permalink":"http://shangliushuai.cn/categories/工具/Linux/"},{"name":"Mac","slug":"工具/Linux/Mac","permalink":"http://shangliushuai.cn/categories/工具/Linux/Mac/"},{"name":"Windows","slug":"工具/Linux/Mac/Windows","permalink":"http://shangliushuai.cn/categories/工具/Linux/Mac/Windows/"}],"tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"http://shangliushuai.cn/tags/杂七杂八/"}]},{"title":"写在五一节后的一些思考","slug":"写在五一节后的一些思考","date":"2019-05-06T16:00:00.000Z","updated":"2019-12-24T00:13:45.619Z","comments":true,"path":"2019/05/07/写在五一节后的一些思考/","link":"","permalink":"http://shangliushuai.cn/2019/05/07/写在五一节后的一些思考/","excerpt":"","text":"突然之间，就想写点东西。 有人问过我，为什么选择北漂？ 当时自己嘴上的回答很简单：自己的行业在西安找一份高工资的工作不容易，尤其是自己还处于处起步阶段，是个前端界的小学生。 其实，说心里话，当时自己心里也没有答案。 这么一两年过去了，可能心里面也有了答案。 一方面，我不想成为一个异类，帝都虽苦，可是不论是早上7点上班还是晚上10点下班，总有大堆大堆的人一起，虽然在外人看会像行尸走肉一样，但是每天真真切切能感受到自己的付出是有价值的，不只体现在收入上，还有个人成长和社会价值上。这样才让我有活着的感觉。 另一方面，生活在更大的城市，就意味着可以见到更广阔的世界、学到更多的东西，去不断完善我的三观。我不想做井底之蛙，这个世界我需要学习的地方还有很多。假如有一天我真的能饱览井底甚至是井上的风光，真不是井底之蛙了，我也依旧会心存一点谦恭。 这两个原因就足以支撑我北漂。虽然前路坎坷，但还有希望。世界就是这样，年轻的时候难免颠沛流离。 我是幸运的，可以做自己喜欢的事业，有自己喜欢的人。 热爱前端，但是确实发现这两年自己的成长还是太慢了。我觉得，一个人的知识面是一个圆圈，知识储备越多，圆圈越大，接触到的面积便越广阔，便能掌握和窥视更多的机会。现在的我的知识面圈子还是不够大，我还是需要更多的努力才能拥有更多的机会。我有自己的理想，但是理想越远大，也就说明我完成它需要更多的努力。 现在感觉，社会整体是浮躁的，当局者迷，我也不能置身事外。这个社会不缺脑袋灵光的人，可缺持之以恒做傻事地聪明人。我不求做一个持之以恒做傻事的聪明人，我只想成为一个可以持之以恒的普通人，为了实现自己的理想一步一个脚印。 希望自己记住自己的目标： 工作方面，开源一个东西，由前端慢慢向全栈过渡。 生活方面，保持现在良好的作息，多运动，保证身体健康。 思想方面，尽可能在生活之余多读几本好书。 人生方面，希望自己在人生的终点，不后悔现在做出的每一个选择。 看似很简单，路还很远。 思绪挺乱，随手记下来，只为了自勉。 希望我自己记住，人最重要的是有一个上升的态势，不要因为外界干扰了自己。 三十年众生马牛，六十年诸佛龙象。","categories":[{"name":"心情","slug":"心情","permalink":"http://shangliushuai.cn/categories/心情/"}],"tags":[{"name":"心情","slug":"心情","permalink":"http://shangliushuai.cn/tags/心情/"}]},{"title":"两道有意思的面试题","slug":"两道有意思的面试题","date":"2019-05-01T16:00:00.000Z","updated":"2019-12-24T00:13:45.617Z","comments":true,"path":"2019/05/02/两道有意思的面试题/","link":"","permalink":"http://shangliushuai.cn/2019/05/02/两道有意思的面试题/","excerpt":"","text":"在面试中遇到了这么两道题，当时没有做出来，挺有意思，记录下来。 一、数组中找出项的组合1从一个数组中找出几个项和为M的所有可能。 当时乍一看想到把所有情况枚举一边，但是仔细看不知道怎么下手，回来仔细想了下，确定了个思路，可以把每一个组合转化成二进制，比如[1, 2, 3, 4]中数组第一项和第三项的组合就可以用1010表示，这样就可以快速列出所有组合的情况，然后算出对应项的和，等于M的就返回。 这个思路需要解决这么几个问题： 如何把所有的组合罗列出来进行遍历？ 如何根据二进制的表示计算出这个组合中项的和？ 如果，规定组合只能有几项，而不是要求所有情况该怎么处理？ 我们来一个一个看。 首先，如何把所有组合罗列出来进行遍历？ 既然决定采用二进制表示，那么最简单的方式实际上就是累加。 例如，[1, 2, 3, 4]组合有16种： 12340000、0001、0010、0011、0100、0101、0110、0111、1000、1001、1010、1011、1100、1101、1110、1111 其实换算成10进制就是0到15，共16中情况，也就是 2的数组长度的次方Math.pow(2, arr.length)，只要一个循环累加就可以。 接着，如何根据这个二进制表示计算项的和？ 我第一时间想到的，就是把这个字符串一位一位遍历，如果字符串的项是1，则进行累加，并把对应的数组中的项记录下来。 1234567let binStr = i.toString(2);binStr.split('').forEach((item, index) =&gt; &#123; if (item === '1') &#123; s += arr[index] temp.push(arr[index]) &#125;&#125;) 这里有个问题，在把一个数利用toString()转换成二进制字符串时，是不会出现0110这样的字符串，而是会出现110，需要补零。 123456789let binStr = i.toString(2);// 对二进制的字符串进行补零，保证字符串长度和数组长度一致binStr = '0'.repeat(arr.length - binStr.length) + binStr;binStr.split('').forEach((item, index) =&gt; &#123; if (item === '1') &#123; s += arr[index] temp.push(arr[index]) &#125;&#125;) 最后，如果限定项数，就需要多加一层过滤，增加一个用来计数的counter来计算每个字符串的项数。 12// 获取数字转化成二进制字符串后有多少个1const counter = num =&gt; num.toString(2).replace(/0/g, '').length; 这三个问题解决后，来看下所有代码。 12345678910111213141516171819202122232425function GetCombBySumFromArray(arr, sum, count) &#123; // 获取数字转化成二进制字符串后有多少个1 const counter = num =&gt; num.toString(2).replace(/0/g, '').length; let len = arr.length, res = []; // 外循环：数组项随机组合的所有可能性组合 for (let i = 0; i &lt; Math.pow(2, len); i++) &#123; if (!count || counter(i) == count) &#123; let s = 0, temp = [], binStr = i.toString(2); // 对二进制的字符串进行补零，保证字符串长度和数组长度一致 binStr = '0'.repeat(arr.length - binStr.length) + binStr; // 内循环，主要作用是把在这个组合中的对应的数组的项相加，推入临时数组 binStr.split('').forEach((item, index) =&gt; &#123; if (item === '1') &#123; s += arr[index] temp.push(arr[index]) &#125; &#125;) // 满足要求 if (s == sum) &#123; res.push(temp) &#125; &#125; &#125; return res;&#125; 来测试下，看下执行结果。 1console.log(GetCombBySumFromArray([-1, 3, 9, 4, 6, -4, 5, 8, 1, 7], 5, 0)); 看起来是正常的，接下来，考虑一个问题，既然已经采用二进制，是不是可以考虑用位运算？答案肯定是可以的，我本身对位运算使用不多，所以借助了下网上的资料，发现有两个地方可以优化。 原本在内循环中是通过拆字符串一项一项比较，其实可以通过位运算去判断这一项是不是在这个组合中 1234567for (let j = 0; j &lt; len; j++) &#123; // 判断当前数是否在这个组合中 if (0b0110 &amp; 1 &lt;&lt; (len - 1 - j)) &#123; s += arr[j] temp.push(arr[j]) &#125;&#125; 循环还是大同小异的循环，只不过，判断的方法变成了(0b0110 &amp; 1 &lt;&lt; (len - 1 - j))，这里才是重点，根据循环，0b0110需要依次和1000、100、10、1进行&amp;运算，这样结果不为0的就表示这项在这个组合中存在。 counter的升级，也是运用了&amp;运算 12345678const counter = num =&gt; &#123; let count = 0 while (num) &#123; num = num &amp; (num - 1) count++ &#125; return count&#125; 来看下升级过后的函数： 12345678910111213141516171819202122232425262728293031const GetCombBySumFromArray = (arr, sum, count) =&gt; &#123; // 获取数字转化成二进制字符串后有多少个1 const counter = num =&gt; &#123; let count = 0 while (num) &#123; num = num &amp; (num - 1) count++ &#125; return count &#125; let len = arr.length, res = []; // 外循环：数组项随机组合的所有可能性组合 for (let i = 0; i &lt; Math.pow(2, len); i++) &#123; if (!count || counter(i) == count) &#123; let s = 0, temp = []; // 内循环，主要作用是把在这个组合中的对应的数组的项相加，推入临时数组 for (let j = 0; j &lt; len; j++) &#123; // 判断当前数是否在这个组合中 if (i &amp; 1 &lt;&lt; (len - 1 - j)) &#123; s += arr[j] temp.push(arr[j]) &#125; &#125; // 满足要求 if (s == sum) &#123; res.push(temp) &#125; &#125; &#125; return res;&#125; 位运算还是挺有意思的，可是平时用的还是不多，导致解决问题时不一定能想起来采用位运算，有机会需要更深入了解下位运算的应用。 这个题应该还有其他解法，先放在这，等后面有功夫再想想其他解法。 二、同心圆 1这样一个同心圆，三种颜色，你用几个div可以做到？ 这个题，当时问道，第一反应就是一个，div+border+box-shadow就可以做到： 12345678910#circle &#123; margin:100px auto; width: 300px; height: 300px; border-radius: 50%; background: aqua; position: relative; border: 50px solid orange; box-shadow: 0px 0px 0px 50px yellow;&#125; 然后后面继续问道，四种颜色呢？ 这时候我第一反应是，CSS的渐变。 12345678#circle &#123; margin:100px auto; width: 300px; height: 300px; border-radius: 50%; background: repeating-radial-gradient(circle, rgb(255, 255, 255) 10%, rgb(0, 0, 0) 20%); position: relative;&#125; 渐变的我话，别说四个，更多的也可以解决。但是要求是不能使用渐变。这个时候就有点懵，面试官这时候提示道CSS的伪元素可以么，想了下，确实可以。 1234567891011121314151617181920212223242526#circle::before &#123; content: ' '; position: absolute; width: 100px; height: 100px; border-radius: 50%; top: 50%; left: 50%; margin-top: -50px; margin-left: -50px; background: purple; z-index: 20;&#125;#circle::after &#123; content: ' '; position: absolute; width: 200px; height: 200px; border-radius: 50%; top: 50%; left: 50%; margin-top: -100px; margin-left: -100px; background: chartreuse; z-index: 10;&#125; 问题解决。以往自己用到before和after多的还是icon或者清楚浮动等，很久不接触，突然想不起来，其实伪元素的作用真的挺大，自己在CSS方面的基础真的还需要再去细细梳理下。前端还是非常有意思的。","categories":[{"name":"前端","slug":"前端","permalink":"http://shangliushuai.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://shangliushuai.cn/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"http://shangliushuai.cn/tags/CSS/"},{"name":"面试题","slug":"面试题","permalink":"http://shangliushuai.cn/tags/面试题/"}]},{"title":"call和bind","slug":"call和bind","date":"2019-04-29T16:00:00.000Z","updated":"2019-12-24T00:13:45.616Z","comments":true,"path":"2019/04/30/call和bind/","link":"","permalink":"http://shangliushuai.cn/2019/04/30/call和bind/","excerpt":"","text":"call、apply和bind常用来显示改变函数运行环境中的this指向，这几天突发奇想如果call.call、bind.bind和bind().band()会是怎样的结果，先记录一下，给出一下我现在认为的结论，后面有时间了，深入研究下。 公共12345678function fn01 () &#123; console.log('fn01:', this); &#125;function fn02 () &#123; console.log('fn02:', this); &#125;let obj = &#123; fn: fn01 &#125;let fn03 = obj.fn;fn01(); // fn01 windowfn02(); // fn02 windowfn03(); // fn01 windowobj.fn(); // fn01 obj 这其中定义了两个函数fn01和fn02以及一个对象，每个方法右面注释是执行主体和this指向。上面的几种是比较常见的情况。 call1234567fn01.call(fn02); // fn01 fn02fn01.call.call(fn02); // fn02 windowfn01.call.call(fn02, fn02); // fn02 fn02fn01.call.call.call(fn02); // fn02 windowfn01.call.call.call.call(fn02); // fn02 windowfn01.call.call.call.call.call(fn02); // fn02 windowfn01.call.call.call.call.call(fn02, fn02, fn02, fn02, fn02); // fn02 fn02 从这开始是主要内容，第一句，是比较常见的方式，执行fn01，this指向改为fn02。 接着就是我的疑惑的地方：call.call 从结果上看，call.call中间插入几个call并不影响最终结果。 注意看下这两句： 12fn01.call.call(fn02); // fn02 windowfn01.call.call(fn02, fn02); // fn02 fn02 按我现在的看法，fn01.call.call(fn02)可能就相当于fn02.call()。 这行代码的运行过程可能是这样：fn01.call执行了call方法，改变了fn01.call的this指向为fn02。但是fn01.call执行的this指向是fn01，所以最终执行主体就变成了fn02。这时候就相当于fn02.call()，因为call没有参数，所以结果this指向了window。 这样看，fn01.call.call(fn02, fn02)相当于fn02.call(fn02)。所以最终结果，fn02是执行主体，this也指向了fn02。 后面加多少个call，原里应该都是一样的，所以不再赘述。 bind12345678910111213141516171819202122232425// bindlet fn04 = fn01.bind();fn04(); // fn01 windowlet fn05 = fn01.bind(fn02);fn05(); // fn01 fn02let fn06 = fn01.bind(fn01).bind(fn01);fn06(); // fn01 fn01let fn07 = fn01.bind(fn01).bind(fn02);fn07(); // fn01 fn01let fn08 = fn01.bind(fn02).bind(fn01);fn08(); // fn01 fn02let fn09 = fn01.bind(fn02).bind(fn02);fn09(); // fn01 fn02let fn10 = fn01.bind(fn02).bind(fn01).bind(fn01);fn10(); // fn01 fn02let fn11 = fn01.bind(fn01).bind(fn02).bind(fn02);fn11(); // fn01 fn01let fn12 = fn01.bind(obj).bind(fn01);fn12(); // fn01 objlet fn13 = fn01.bind.bind(fn02);fn13(); // 无输出let fn14 = fn13();fn14(); // fn02 windowlet fn15 = fn13(fn01);fn15(); // fbn02 fn01 bind有两种情况一种是bind.bind，一种是bind().bind()。 首先来看bind().bind()，无论链式多少个，实际上都以第一个bind()中的参数为准，原因可能是bind函数返回的函数中的this已经被外层的bind函数（第一个bind函数）确定，后面再进行bind操作传进来的参数没有做处理。但此原因暂时没有验证，仅作猜想。 接着是bind.bind，bind.bind可能和call.call类似，fn01.bind执行了bind方法，改变了fn01.bind的this指向为fn02。但是fn01.bind执行的this指向是fn01，所以最终执行主体就变成了fn02。这时候就相当于fn02.bind()，因为bind没有参数，所以结果this指向了window。执行一次fn02.bind()（也就是fn13），返回的函数执行后，就和call.call的结论类似，只是最后一次传参的方式不太一样。 以上所有结论仅是猜想，还需要从更加深入的研究this指向还有call、bind的机制，设计出合理的验证方式。因时间原因，先放一放。","categories":[{"name":"前端","slug":"前端","permalink":"http://shangliushuai.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://shangliushuai.cn/tags/JavaScript/"}]},{"title":"你不知道的JavaScript","slug":"你不知道的JavaScript","date":"2019-04-17T16:00:00.000Z","updated":"2019-12-24T00:13:45.616Z","comments":true,"path":"2019/04/18/你不知道的JavaScript/","link":"","permalink":"http://shangliushuai.cn/2019/04/18/你不知道的JavaScript/","excerpt":"","text":"JavaScript中总会出现很多有意思的小地方，这里会把我遇到的问题进行总结，并不定期更新。 1. 函数提升和变量提升的优先级？函数的执行一般有这么几个步骤： 开辟一个私有作用域 形参赋值 变量提升和函数提升 代码按顺序执行 其中第三步，函数声明的提升优先级要高于变量提升。 2. vue组件的data属性为什么是一个函数返回一个对象而不是直接一个对象？为了防止vue组件的各个实例之间相互污染各自的数据 3. 为什么0.1 + 0.2 !== 0.3JavaScript精度处理采用IEEE 754标准，计算机中用二进制来存储小数，而大部分小数转成二进制之后都是无限循环的值，因此存在取舍问题，也就是精度丢失，所以会出现0.1 + 0.2 !== 0.3的情况。 检测方法应该利用Number.EPSILON：0.1 + 0.2- 0.3 &gt; Number.EPSILON。 Number.EPSILON 属性表示 1 与Number可表示的大于 1 的最小的浮点数之间的差值。 4. 为什么String、Boolean和Number的基本类型数据可以调用方法？ECMAScript提供了三个特殊的引用类型：String、Boolean和Number，被称为基本包装类型，与普通引用类型的主要区别就是对象的生存期。 实际上在基本数据类型上调用方法的过程是这样的： 创建一个基本包装类型的实例 在实例上调用指定的方法 销毁这个实例 5. 定义Object的不同方式和区别先上代码： 1234567891011121314151617181920212223242526272829var o1 = &#123;name: 'o1'&#125;;var o2 = new Object(&#123;name: 'o2'&#125;);var M = function () &#123; this.name = 'o3'&#125;;var o3 = new M();var N = class &#123; constructor () &#123; this.name = 'o4'; &#125;&#125;var o4 = new N();var P = &#123;name: 'o5'&#125;;var o5 = Object.create(P);console.log(o1.constructor === Object); // trueconsole.log(o2.constructor === Object); // trueconsole.log(o3.constructor === M); // trueconsole.log(o4.constructor === N); // trueconsole.log(o5.constructor === Object); // trueconsole.log(o1.hasOwnProperty('name')); // trueconsole.log(o2.hasOwnProperty('name')); // trueconsole.log(o3.hasOwnProperty('name')); // trueconsole.log(o4.hasOwnProperty('name')); // trueconsole.log(o5.hasOwnProperty('name')); // false 虽然上面有五种定义方式，但是在我看来，按照返回的对象区分，应该算是三种，o1和o2是一种，o3和o4是一种，o5是一种。 第一种方式构造函数是Object，属性是自己的私有属性 第二种方式构造函数是自己的类，属性是自己的私有属性 第三种方式构造函数是Object，属性是在原型链上的共有属性 6. 深拷贝和浅拷贝的区别 浅拷贝：拷贝前后对象的基本数据不受影响，只拷贝一层，不能对对象中的子对象进行拷贝 深拷贝：对对象中的子对象进行递归拷贝，拷贝前后的两个对象互不影响","categories":[{"name":"前端","slug":"前端","permalink":"http://shangliushuai.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://shangliushuai.cn/tags/JavaScript/"},{"name":"小知识","slug":"小知识","permalink":"http://shangliushuai.cn/tags/小知识/"}]},{"title":"Vue Cli 3.0相关问题总结","slug":"Vue-Cli-3-0相关问题总结","date":"2019-03-29T16:00:00.000Z","updated":"2019-12-24T00:13:45.613Z","comments":true,"path":"2019/03/30/Vue-Cli-3-0相关问题总结/","link":"","permalink":"http://shangliushuai.cn/2019/03/30/Vue-Cli-3-0相关问题总结/","excerpt":"","text":"1. 打包出现无用htmlKA管理员平台登录页面复用KA客户平台登录页面，登录页面需要把部分js通过Webpack打包方式插入到页面中。由于管理员平台采用Vue-Cli3，Vue-Cli3中帮我们处理了需要HtmlWebpackPlugin的地方，在vue.config.js中配置page就会自动编译为HtmlWebpackPlugin的相关配置。但因为登录页面login.html中需要打包进去几个js文件，js文件如果也写在pages配置中，会导致build后多出无用的html文件。 如上图，这样打包会导致出现hover3D.html、stage.html和logincss.html几个无用文件。 解决方案是把除了index的部分注释掉，然后把login相关配置写在configureWebpack中。沿用以前的配置，配置写在entry中（不过官方貌似不推荐这么做），然后配置登录页的HtmlWebpackPlugin插件。Vue-Cli3会把configureWebpack中的内容merge到webpack的配置中去。 这样打包就不会出现无用的html文件。 2. 打包部署后，js不执行，不报错。 在HtmlWebpackPlugin配置的chunks中加入’chunk-vendors’, ‘chunk-common’解决 3. static文件夹中内容打包后没有复制到dist采用阿里的iconfont，下载字体文件放在/static/fonts文件夹中，打包后并没有出现在/dist/fonts中。 VUE CLI 3中不会默认打包static中的文件，需要把文件放在/public中。把字体文件放在/public/fonts中，字体文件成功打包到/dist/fonts中","categories":[{"name":"前端","slug":"前端","permalink":"http://shangliushuai.cn/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://shangliushuai.cn/tags/Vue/"},{"name":"Vue Cli","slug":"Vue-Cli","permalink":"http://shangliushuai.cn/tags/Vue-Cli/"}]},{"title":"一个实现不清空Vuex Store的刷新页面方式","slug":"一个实现不清空Vuex-Store的刷新页面方式","date":"2019-03-15T16:00:00.000Z","updated":"2019-12-24T00:13:45.611Z","comments":true,"path":"2019/03/16/一个实现不清空Vuex-Store的刷新页面方式/","link":"","permalink":"http://shangliushuai.cn/2019/03/16/一个实现不清空Vuex-Store的刷新页面方式/","excerpt":"","text":"最近某个业务需求，需要在某个时刻更新页面数据，因为有些页面接口比较多，全部采取直接刷新页面的方式。页面刷新有两种方式，window.location.reload()和this.$router.go(0)。但是两种刷新会导致清空store，部分需要store数据支持的功能就会出现问题。为了保证store的数据，使路由变成其他再变回来可能是比较好的方式。 为了不影响其他页面，所以写了个refresh.vue的页面，专门用来刷新页面。需要刷新的时候，跳转到refresh页面。refresh.vue只有一个beforeRouteEnter的方法。 原本选用的是vue-router的push和go方法搭配，后面发现这样处理浏览器的前进按钮会启用，但是前进后无反应，比较怪异，最后选择用vue-router的replace替代，replace()方法会替换当前路由，不会对浏览器路由造成影响。","categories":[{"name":"前端","slug":"前端","permalink":"http://shangliushuai.cn/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://shangliushuai.cn/tags/Vue/"}]},{"title":"祝小姐姐生日快乐！","slug":"祝小姐姐生日快乐！","date":"2019-03-15T16:00:00.000Z","updated":"2019-12-24T00:13:45.612Z","comments":true,"path":"2019/03/16/祝小姐姐生日快乐！/","link":"","permalink":"http://shangliushuai.cn/2019/03/16/祝小姐姐生日快乐！/","excerpt":"","text":"祝我最爱的小姐姐生日快乐！xn–fbr11h79q，xn–6qq986b3xl","categories":[{"name":"心情","slug":"心情","permalink":"http://shangliushuai.cn/categories/心情/"}],"tags":[{"name":"心情","slug":"心情","permalink":"http://shangliushuai.cn/tags/心情/"}]},{"title":"前端与单元测试","slug":"前端与单元测试","date":"2019-01-31T16:00:00.000Z","updated":"2019-12-24T00:13:45.605Z","comments":true,"path":"2019/02/01/前端与单元测试/","link":"","permalink":"http://shangliushuai.cn/2019/02/01/前端与单元测试/","excerpt":"","text":"本文转载自知乎@大笑，原文链接：https://zhuanlan.zhihu.com/p/55887740 先来几个专业词汇，这样显得高大上一点（不存在的=。=） BDD: Behavior-Driven Development (行为驱动开发)TDD: Test-Driven Development (测试驱动开发)ATDD: Acceptance Test Driven Development(验收测试驱动开发) 好，说完了，然后我们废话不多说，直接进入正题。我会从多个测试框架入手，结合各种断言库，用代码方式说明。 单元测试（Unit Testing），是指对软件中的最小可测试单元进行检查和验证。 当今所有著名的框架都要进行单元测试，经过测试的框架，它的信任度显然高于未测试的框架。 这里，我们介绍一下karma这个前端的单元测试框架。 Spectacular Test Runner for Javascripthttp://karma-runner.github.io/3.0/index.html 首先我们来安装一波：新建一个空文件夹，然后在空文件夹中打开终端输入 1234npm init -y(sudo) npm install karma-cli -gnpm install karma karma-jasmine karma-chrome-launcher jasmine-core --save-devnpm install karma-phantomjs-launcher --save-dev 你安装karma-cli这个倒是说得过去，可是这个jasmine是啥，这个chrome-launcher和phantomjs-launcher又是啥？ 没错，单说测试框架是不完整的，必须要有断言库与之相配合，这里的jasmine就是断言库。 啥是断言（assert）？ 根据概念： 断言是编程术语，表示为一些布尔表达式，程序员相信在程序中的某个特定点该表达式值为真，可以在任何时候启用和禁用断言验证，因此可以在测试时启用断言而在部署时禁用断言。 一言以蔽之，老子/老娘说啥就是啥！听起来好像挺霸道的。那么具体呢？ 顺着karma的正常流程向下走，我们来写一个简单的单元测试。在终端输入： 1karma init 你会发现，需要做一个调查问卷了，问题如下： 1234567891011121314151617181920212223242526272829303132&gt; 请问你要用哪种测试框架呢？&gt; 按tab键选择，按回车键进入下一个问题。&gt; jasmine (因为我们安装的是jasmine，选什么断言库都别忘了安装一下)&gt; 您想要使用Require.js么？ &gt; 选择yes的话，会安装Require.js插件。&gt; 按tab键选择，按回车键进入下一个问题。 &gt; no (这里我们选择no)&gt; 你想要在什么浏览器中测试呢？ &gt; 按tab键选择，输入空字符串进入下一个问题。 &gt; Chrome&gt; PhantomJS&gt;注：上面的选择这两个浏览器的原因是我们之前安装了这两个浏览器的启动器（launcher）&gt; 需要测试的源文件和测试命令文件放在哪呢？你可以使用通配符(glob patterns)来匹配文件，比如：&quot;js/*.js&quot; 或 &quot;test/**/*Spec.js&quot;输入空字符串进入下一个问题。 &gt;(这里先留空，可根据测试情况灵活配置)&gt;在符合匹配的文件中有哪些文件可以排除在外呢？你可以使用通配符来匹配文件，比如：&quot;**/*.swp&quot;输入空字符串进入下一个问题。 &gt; &gt; 你想要Karma根据文件的变化立即做出响应么？&gt; yes 之后，你就会发现你的文件夹里多了一个文件： 打开这个文件，你会发现里面是一个配置项函数： 1234567891011121314module.exports = function(config) &#123; basePath: &apos;&apos;, // 根路径将会同files和excluede项中的相对路径相关联 frameworks: [&apos;jasmine&apos;], // 所使用的测试框架 files: [], // 这里是需要测试的文件列表，有多种配置方式 exclude: [], // 测试过程中排除在外的文件列表 reporters: [&apos;progress&apos;], // 测试结果的汇报方式， port: 9876, // web服务器接口 colors: true, // 是否使用彩色报告 logLevel: config.LOG_INFO, // 日志级别，可配置的值有: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG autoWatch: true, // 是否自动观测文档改变并执行测试命令 browsers: [&quot;Chrome&quot;, &quot;PhantomJS&quot;], // 用哪些浏览器测试呢 singleRun: false, // 持续集成模式，如果设置成true，Karma将自行捕获浏览器，运行测试并根据结果退出, concurrency: Infinity // 并发数，同时跑多少个浏览器进行测试，默认无上限&#125; 默认会生成的配置项就是上面这些，更完整的配置请点我这里稍微提一下browsers配置项，它可以配置高达8种浏览器： 每一种都需要安装对应的launcher。其中有两个需要注意chromeHeadless和PhantomJS。这两个是无头浏览器。所谓无头浏览器就是没有脑袋的浏览器。 无头浏览器即headless browser，是一种没有界面的浏览器。既然是浏览器那么浏览器该有的东西它都应该有，只是看不到界面而已。因此这种浏览器没有渲染UI的过程，用于测试时的速度很快。 这就回答了上文launcher是啥的问题。毕竟，没有浏览器靠脑补可没法测试啊（真实） 言归正传。我们回到karma测试本身。接下来，我们修改一下配置： 1files: [&quot;src/srcTest/**/*.js&quot;, &quot;test/unit/**/*.js&quot;] 注意，上述写法只是配置写法中的一种, 配置的文件位置也是随您自己指定，更详细的配置请点我 采用上文写法的话，我们在files数组里面配置的第一项是需要测试的文件，第二项就是用什么方法去测试它的文件。 因此，我们也在文件里创建对应的文件夹： 这里有一个要注意的点。我们的需要测试的文件和测试驱动文件的名字是一一对应的，区别就在于测试驱动文件的名字后要加上.spec 那么我们就在srcTest的文件里面写点什么吧…. newBee.js 123456// 减法函数function minus(x) &#123; return function(y) &#123; return x - y; &#125;;&#125; testKarma.js 123456789101112131415161718192021222324252627// 加法函数function add(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;// 乘法函数function multi(x) &#123; return function(y) &#123; return x * y; &#125;;&#125;//if函数测试function ifTest(boolean) &#123; if (boolean) &#123; return &quot;热热&quot;; &#125; else &#123; return &quot;凉凉&quot;; &#125;&#125;// 反转字符串function reverseStr (string) &#123; return string.split(&quot;&quot;).reverse().join(&quot;&quot;);&#125; 那么接下来，就在.spec文件里写入对应的测试断言。我滴个龟龟，终于说到断言了。 因为我们这里使用的是Jasmine，因此就先放一下它的官网。 jasmine.github.iohttps://jasmine.github.io/api/edge/global 我们结合实例来说文档 newBee.spec.js 123456describe(&quot;newBee单元测试&quot;, function() &#123; it(&quot;减法函数测试&quot;, function() &#123; var minus7 = minus(7); expect(minus7(6)).toBe(0); &#125;);&#125;); testKarma.spec.js 123456789101112describe(&quot;testKarma单元测试&quot;, function() &#123; it(&quot;如果函数测试&quot;, function() &#123; expect(ifTest(true)).toBe(true); expect(ifTest(false)).toBe(&quot;凉凉&quot;); &#125;); it(&quot;回文函数测试&quot;, function() &#123; expect(reverseStr(&apos;abc&apos;)).toEqual(&apos;cba&apos;); &#125;)&#125;); 基本的格式就是这样的，下面来解释一下 1234567891011121314151617181920212223242526// 分组describe(), 这个是可以嵌套的，并且每个单独的测试都有beforeAll, afterAll, beforeEach和afterEachdescribe(&quot;这里写测试群组的名称&quot;, function()&#123; // 具体的测试，it(), 当其中所有的断言都为true时，则通过；否则失效。 it(&apos;这里写具体测试的名称&apos;, function()&#123; var a = true; // 期望, expect()。 匹配，to*() // 每个匹配方法在期望值和实际值之间执行逻辑比较 // 它负责告诉jasmine断言的真假，从而决定测试的成功或失败 // 木有错，老子/老娘说啥就是啥 expect(a).toBe(true); // 这是肯定断言 expect(!a).not.toBe(true); // 这是否定断言 // jasmine内置的匹配方法有很多，亦可自定义匹配方法 // toBe() // toEqual() // toMatch() // toBeUndefined() // toBeNull() // toBeTruthy() // toContain() // toBeLessThan() // toBeCloseTo() // toThrowError() // 等等等等 &#125;)&#125;) 那么，测试方法写完了，我们来实际运行一下测试吧。打开终端，输入： 1karma start 就会在终端看到 可以看到，我们的测试在Chrome和PhantomJS浏览器中分别测试了的5个方法，都有2个没有通过测试，没错，我们当初在写测试的时候故意写错了（这是真的）。 那么我们把测试修改成真值。 newBee.spec.js 123456describe(&quot;newBee单元测试&quot;, function() &#123; it(&quot;减法函数测试&quot;, function() &#123; var minus7 = minus(7); expect(minus7(6)).toBe(1); &#125;);&#125;); testKarma.spec.js 1234it(&quot;如果函数测试&quot;, function() &#123; expect(ifTest(true)).toBe(&quot;热热&quot;); expect(ifTest(false)).toBe(&quot;凉凉&quot;);&#125;); 结果是： 全部SUCCESS, 撒花。 到这里，一个基本的测试流程就走完了。然而，这并非终点。 其实，还能更进一步的。我们打开终端： 1npm install karma-coverage --save-dev 然后打开karma.conf.js, 添加一些配置项 12345678910111213141516// 这里配置哪些文件需要统计测试覆盖率，例如，如果你的所有代码文件都在src文件夹中，你就需要如下配置preprocessors: &#123; &quot;src/srcTest/*.js&quot;: &quot;coverage&quot;&#125;,// 新增coverageReporter选项// 配置覆盖率报告的查看方式，type查看类型，可以取值html、text等等，dir输出目录coverageReporter: &#123; dir: &quot;docs/unit&quot;, reporters: [ &#123; type: &quot;html&quot;, subdir: &quot;report-html&quot; &#125; ]&#125;,reporters: [&apos;progress&apos;, &quot;coverage&quot;] // 没错，reporters里面新增了一个coverage 然后保存，再运行一次karma start 接着会发现你的项目里多了一个文件夹 用浏览器打开index.html。就会看到 这就是你所写的js的测试覆盖率。 这样看起来是不是高大上了一些呢？ 这里就有一个问题了。普通的js可以测试，可是我是写Vue的啊，Vue组件怎么测试呢？很简单，Vue官网有非常详细的测试教程。甚至还有专用的测试工具和测试说明 彳亍口巴，你说的这些个单元测试看起来花里胡哨的，实际作用是什么呢？ 单元测试的好处 单元测试不但会使你的工作完成得更轻松。而且会令你的设计会变得更好，甚至大大减少你花在调试上面的时间。 提高代码质量 减少bug, 快速定位bug 使修改和重构可以更放心 显得专业 单元测试的缺点 开发人员要花费时间在写测试代码上，然而又不会给你加工资…小项目写测试只能单纯的增加开发时间和成本，然而又不会给你加工资…我写了测试除了懂测试的人能看懂，别人又不知道，然而还不会给你加工资… 别别别，别打我…你先听我道(hu)理(jiao)讲(man)完(chan)。 对于所编写的代码，你在调试上面画了多少时间？ 对于以前你自认为正确的代码，而实际上这些代码却存在重大的bug，你花了多少时间在重新确认这些代码上面？ 对于一个别人报告的bug，你花了多少时间才找出导致这个bug的源码位置？ 对于那些没有使用单元测试的程序员而言，上面这些问题所耗费的时间的是逐渐增加的，而且项目越深入，花费的时间越多；另一方面，适当的单元测试却可以很大程度地减少这些时间，从而为你腾出足够的时间来编写所有的单元测试——甚至可能还有剩余的空闲时间。 更加真实的是，主流的框架必须要写测试 不想当程序员的设计师不是好运维。 —-鲁迅 作为一个程序员，如果你想要让自己写的框架放到github和npm上能够为世界上的其他人所用。那么一个最基本的前提就是————代码没有BUG。可是，你的怎么向语言不通思维不同的人解释你的JavaScript库确实足够健壮呢。这个时候就需要单元测试出场了。 主流前端框架虽然在所使用的测试库（karma、jest、QUnit）和断言库（assert、jasmine、 chai）上略有差别，但Vue、React、Angular、Underscore甚至是jQuery都写了单元测试。 来个石锤 下面我们看一看Vue的测试是怎么写的： 1234git clone https://github.com/vuejs/vue.gitnpm installnpm run test unit // 这里可以看到单元测试npm run test // 这里就看全部的测试 Vue的测试覆盖率为 举例：v-show的测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// import Vue from &apos;vue&apos;describe(&apos;Directive v-show&apos;, () =&gt; &#123; it(&apos;should check show value is truthy&apos;, () =&gt; &#123; const vm = new Vue(&#123; template: &apos;&lt;div&gt;&lt;span v-show=&quot;foo&quot;&gt;hello&lt;/span&gt;&lt;/div&gt;&apos;, data: &#123; foo: true &#125; &#125;).$mount() expect(vm.$el.firstChild.style.display).toBe(&apos;&apos;) &#125;) it(&apos;should check show value is falsy&apos;, () =&gt; &#123; const vm = new Vue(&#123; template: &apos;&lt;div&gt;&lt;span v-show=&quot;foo&quot;&gt;hello&lt;/span&gt;&lt;/div&gt;&apos;, data: &#123; foo: false &#125; &#125;).$mount() expect(vm.$el.firstChild.style.display).toBe(&apos;none&apos;) &#125;) it(&apos;should update show value changed&apos;, done =&gt; &#123; const vm = new Vue(&#123; template: &apos;&lt;div&gt;&lt;span v-show=&quot;foo&quot;&gt;hello&lt;/span&gt;&lt;/div&gt;&apos;, data: &#123; foo: true &#125; &#125;).$mount() expect(vm.$el.firstChild.style.display).toBe(&apos;&apos;) vm.foo = false waitForUpdate(() =&gt; &#123; expect(vm.$el.firstChild.style.display).toBe(&apos;none&apos;) vm.foo = &#123;&#125; &#125;).then(() =&gt; &#123; expect(vm.$el.firstChild.style.display).toBe(&apos;&apos;) vm.foo = 0 &#125;).then(() =&gt; &#123; expect(vm.$el.firstChild.style.display).toBe(&apos;none&apos;) vm.foo = [] &#125;).then(() =&gt; &#123; expect(vm.$el.firstChild.style.display).toBe(&apos;&apos;) vm.foo = null &#125;).then(() =&gt; &#123; expect(vm.$el.firstChild.style.display).toBe(&apos;none&apos;) vm.foo = &apos;0&apos; &#125;).then(() =&gt; &#123; expect(vm.$el.firstChild.style.display).toBe(&apos;&apos;) vm.foo = undefined &#125;).then(() =&gt; &#123; expect(vm.$el.firstChild.style.display).toBe(&apos;none&apos;) vm.foo = 1 &#125;).then(() =&gt; &#123; expect(vm.$el.firstChild.style.display).toBe(&apos;&apos;) &#125;).then(done) &#125;) it(&apos;should respect display value in style attribute&apos;, done =&gt; &#123; const vm = new Vue(&#123; template: &apos;&lt;div&gt;&lt;span v-show=&quot;foo&quot; style=&quot;display:block&quot;&gt;hello&lt;/span&gt;&lt;/div&gt;&apos;, data: &#123; foo: true &#125; &#125;).$mount() expect(vm.$el.firstChild.style.display).toBe(&apos;block&apos;) vm.foo = false waitForUpdate(() =&gt; &#123; expect(vm.$el.firstChild.style.display).toBe(&apos;none&apos;) vm.foo = true &#125;).then(() =&gt; &#123; expect(vm.$el.firstChild.style.display).toBe(&apos;block&apos;) &#125;).then(done) &#125;) it(&apos;should support unbind when reused&apos;, done =&gt; &#123; const vm = new Vue(&#123; template: &apos;&lt;div v-if=&quot;tester&quot;&gt;&lt;span v-show=&quot;false&quot;&gt;&lt;/span&gt;&lt;/div&gt;&apos; + &apos;&lt;div v-else&gt;&lt;span @click=&quot;tester=!tester&quot;&gt;show&lt;/span&gt;&lt;/div&gt;&apos;, data: &#123; tester: true &#125; &#125;).$mount() expect(vm.$el.firstChild.style.display).toBe(&apos;none&apos;) vm.tester = false waitForUpdate(() =&gt; &#123; expect(vm.$el.firstChild.style.display).toBe(&apos;&apos;) vm.tester = true &#125;).then(() =&gt; &#123; expect(vm.$el.firstChild.style.display).toBe(&apos;none&apos;) &#125;).then(done) &#125;)&#125;) 只要你的测试覆盖率足够高，你就可以在著名的GitHub装逼网站Codecov搞一个覆盖率标签了。就像下面这个： 怎么样，这样你所写的框架，是不是就逼格满满？ 所以你还在等什么，测不了吃亏，测不了上当，赶紧在自己的代码中加入测试吧，只要998，代码逼格带回家！","categories":[{"name":"前端","slug":"前端","permalink":"http://shangliushuai.cn/categories/前端/"}],"tags":[{"name":"转载","slug":"转载","permalink":"http://shangliushuai.cn/tags/转载/"},{"name":"单元测试","slug":"单元测试","permalink":"http://shangliushuai.cn/tags/单元测试/"}]},{"title":"封装一个浏览器文本复制功能的方法","slug":"封装一个浏览器文本复制功能的方法","date":"2019-01-11T16:00:00.000Z","updated":"2019-12-24T00:13:45.604Z","comments":true,"path":"2019/01/12/封装一个浏览器文本复制功能的方法/","link":"","permalink":"http://shangliushuai.cn/2019/01/12/封装一个浏览器文本复制功能的方法/","excerpt":"","text":"这段时间，某个需求中，有个功能，需要点击一个button复制某段显示出来的text，于是需要自己动手简单封装一个copy方法。 首先，完成复制，必须调用document的一个api： 1document.execCommand('copy'); execCommand的api链接：https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand 这个是必须的，接下来，来介绍下大体思路： 在document中建立一个看不见的input 把需要复制的文字复制给input的value 选择这些文字 调用document.execCommand(&#39;copy&#39;); 在第三步有个兼容性问题，安卓手机可以直接调用input的select方法选中文字，但是iOS调用select方法只会选中，并不会默认选中文字，必须手动执行一个setSelectionRange方法来选中这些文字。否则，iOS上的复制无法生效。 12345678910111213141516171819202122232425function copy (text) &#123; var input = document.createElement('input'); input.setAttribute('readonly', 'readonly'); input.style.position = 'fixed'; input.style.top = 0; input.style.left = 0; input.style.border = 'none'; input.style.outline = 'none'; input.style.resize = 'none'; input.style.background = 'transparent'; input.style.color = 'transparent'; input.value = text; document.body.appendChild(input); if (utils.isIOS()) &#123; input.setSelectionRange(0, text.length); &#125; else &#123; input.select(); &#125; try &#123; document.execCommand('copy'); &#125; catch (err) &#123; console.log('unable to copy', err); &#125; document.body.removeChild(input);&#125; 这样一个文本复制的方法就完成了。","categories":[{"name":"前端","slug":"前端","permalink":"http://shangliushuai.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://shangliushuai.cn/tags/JavaScript/"}]},{"title":"刮卡效果滑动轨迹偏移","slug":"刮卡效果滑动轨迹偏移","date":"2018-12-21T16:00:00.000Z","updated":"2019-12-24T00:13:45.603Z","comments":true,"path":"2018/12/22/刮卡效果滑动轨迹偏移/","link":"","permalink":"http://shangliushuai.cn/2018/12/22/刮卡效果滑动轨迹偏移/","excerpt":"","text":"1. 问题描述 初始需求要求一个刮刮卡的效果，代码完成后，发现计算没有问题，但是结果和触摸点偏移，如上图（仅供参考，不代表实际情况） 2. 原因 经排查发现，因为需要使刮卡区域居中，使用了css3属性transform中的translateX。但该属性会对触摸的相关计算产生影响，导致偏差，修改为其他方式居中解决。","categories":[{"name":"前端","slug":"前端","permalink":"http://shangliushuai.cn/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://shangliushuai.cn/tags/CSS/"}]},{"title":"小程序调研报告","slug":"小程序调研报告","date":"2018-12-09T16:00:00.000Z","updated":"2019-12-24T00:13:45.597Z","comments":true,"path":"2018/12/10/小程序调研报告/","link":"","permalink":"http://shangliushuai.cn/2018/12/10/小程序调研报告/","excerpt":"","text":"一、目的结合团队现阶段技术栈，找到目前最适合团队快速上手小程序的技术栈。 二、框架1. 现有框架对比 1 小程序 wepy mpvue megalo Taro 语法规范 小程序规范 类Vue规范 Vue规范 Vue规范 React规范 模板系统 字符串模板 字符串模板 字符串模板 字符串模板 JSX 类型系统 不支持 业务代码 业务代码 业务代码 业务代码 + JSX模板 组件规范 小程序组件 小程序组件 html标签 + 小程序组件 html标签 + 小程序组件 小程序组件 样式规范 wxss sass, less, stylus sass, less, postcss sass, less, postcss 组件化 小程序组件化 自定义组件化 Vue组件化规范 Vue组件化规范 React组件化规范 多端复用 无 复用为H5 复用为H5，将通过Weex支持移动端 复用为H5 复用为H5，将通过RN支持移动端 自动构建 无 内建构件系统 Webpack构建 内建构建系统 + Webpack构建 内建构建系统 + Webpack构建 上手成本 全新学习 熟悉Vue + wepy 熟悉Vue 熟悉Vue 熟悉React 数据流管理 无 Redux Vuex Vuex Redux 2. mpvue和megalo对比(1) 不同点对比 1 mpvue megalo vue语法支持程度 大部分vue语法 mpvue基础上，多支持filter，v-html，slot-scope，复杂差值表达式 单页面结构 vue页面文件、小程序配置文件、js文件 vue页面文件、js文件（配置文件放在vue页面文件中） 新增页面操作 修改app.json 修改app.json + 修改webpack配置 文档详细程度 起步早，相对丰富 起步晚，文档简单 (2) 试用megalo 出现问题（后期更新可能解决） megalo iconPath要用相对定位，否则报错 1234567// index.js&#123; \"pagePath\": \"pages/index/index\", \"text\": \"首页\", \"iconPath\": \"../static/2018-12-10-小程序调研报告/index.png\", \"selectedIconPath\": \"../static/2018-12-10-小程序调研报告/index-active.png\"&#125; megalo pages可以用^标志首页，但增加页面需要改webpack entry 123456789// webpack.base.config.jsentry: &#123; 'app': _.resolve( 'src/index.js' ), 'pages/index/index': _.resolve( 'src/pages/index/index.js' ), 'pages/logs/index': _.resolve( 'src/pages/logs/index.js' ), 'pages/create/index': _.resolve( 'src/pages/create/index.js' ), 'pages/table/index': _.resolve( 'src/pages/table/index.js' ), 'pages/record/index': _.resolve( 'src/pages/record/index.js' ),&#125; megalo没有自己的vue-cli模板，初始化项目比较麻烦 megalo每个页面的vue文件需要设置mpType: ‘page’ 12345678910// index.vueexport default &#123; mpType: 'page', data () &#123; return &#123; motto: 'Hello World', userInfo: &#123;&#125; &#125; &#125;&#125; megalo用小程序开发工具指向的是dist，个人感觉有时报错需要重启小程序开发工具或者删除dist重新打包才能解决 用官方megalo-demo，项目可以跑起来，新增页面无问题，但无法引第三方ui库，引用静态资源无法打包到dist中（因时间原因，无法具体研究webpack配置需要怎么写） 使用vue-cli初始化项目，根据官网文档修改webpack配置后编译，框架需要的一个包直接报错（因时间原因，不再具体研究） 三、UI库1. 不能使用常见前端移动端UI库的原因小程序架构如图： 整个小程序由两个 webview 组成，代码分为 UI 层和逻辑层。UI 层运行在第一个 WebView 当中，执行 DOM 操作和交互事件的响应，里面是 WAWebview.js 代码及编译后的内容。逻辑层执行在（第二个webview 中）独立的 JS 引擎中（iOS：JavaScriptCore, android：X5 JS解析器；统称 JSCore；开发工具中，nwjs Chrome 内核），WAService.js 代码和业务逻辑。 当我们对 view 层进行事件操作后，会通过 WeixinJSBridge 将数据传递到 Native 系统层。Native 系统层决定是否要用 native 处理，然后丢给 逻辑层进行用户的逻辑代码处理。逻辑层处理完毕后会将数据通过 WeixinJSBridge 返给 View 层。View 渲染更新视图。 UI和逻辑分开，有两个好处，一个是并行处理避免js运行时间长导致ui卡顿加快首屏渲染，另一个是不支持DOM操作，完全数据驱动。 按照小程序官方文档说明，页面的脚本逻辑是在JsCore中运行，JsCore是一个没有窗口对象的环境，所以不能在脚本中使用window，也无法在脚本中操作组件。 2. 小程序常见UI库对比 WeUI iView WeApp Vant WeApp Wux WeApp MinUI 组件数量 20+ 30+ 30+ 60+ 30+ github star数 7.6k+ 2.8k+ 7.1k+ 2.3k+ 2.8k+ 半年内open issue数 &lt;10 190+ 10+ 10+ 20+ 半年内closed issue数 &lt;10 40+ 320+ 60+ &lt;10 半年内版本更新次数 0 &lt;10 20+ 10+ &lt;10 数据截止2018年11月 经过测试，UI库组件在一般项目开发中性能差距不大，结合上表数据来看，Vant的开发人员是最活跃的，使用人数最多，可以作为选择。 3. mpvue引入UI库（vant/iview/wux）方式(1) 下载组件库（download zip/git clone/npm）获取ui库的dist文件夹并放入项目static中 (2) 更改配置Webpack.base.config=&gt;module=&gt;rules 1234567891011121314// webpack.base.config.js&#123; test: /\\.js$/, include: [resolve('src'), resolve('test'), resolve('static/vant')], use: [ 'babel-loader', &#123; loader: 'mpvue-loader', options: &#123; checkMPEntry: true &#125; &#125;, ]&#125; (3) 引入组件在要使用组件的页面文件夹下的main.json中（没有新建），引入组件 1234567// main.json&#123; \"usingComponents\": &#123; \"v-button\": \"/static/vant/button/index\", \"v-icon\": \"/static/vant/icon/index\" &#125;&#125; (4) 使用组件在.vue文件中的template标签中直接使用，不需要import引入 四、采坑（mpvue + vant） 使用vant需要开启小程序ES6转ES5功能（右上角——详情），否则报错 Notify和Dialog import引入需要相对路径，否则无法找到模块 使用ui框架，双向绑定需要自己绑定change事件，mpvue做了双向绑定，但是只针对于input radio和checkbox和cell-group嵌套使用，因无法获取component，无法按照vant官方文档操作，只能点击勾选的对号进行选择，或者自己封装onchange事件 12345678910111213141516171819&lt;!-- html结构 --&gt;&lt;v-checkbox-group :value=\"tablePropList\" @change=\"handleChange\"&gt; &lt;v-cell-group&gt; &lt;v-cell v-for=\"(item, index) in tablePropListData\" :key=\"index\" :title=\"item.label\" :data-prop=\"item.prop\" clickable @click=\"handleCheckboxClick($event, item, index)\"&gt; &lt;v-checkbox :class=\"'checkbox-' + item.prop\" :name=\"item.prop\"&gt; &lt;/v-checkbox&gt; &lt;/v-cell&gt; &lt;/v-cell-group&gt;&lt;/v-checkbox-group&gt; 123456789101112131415161718// vant官网方法handleCheckboxClick (e, item, index) &#123; // 无法获取checkbox let &#123; prop &#125; = e.currentTarget.dataset let checkbox = this.$root.$mp.page.selectComponent(`.checbox-$&#123;prop&#125;`) checkbox.toggle()&#125;// 自己编写change事件触发的方法handleCheckboxClick (e, item, index) &#123; let prop = item.prop if (this.tablePropList.includes(prop)) &#123; let index = this.tablePropList.indexOf(prop) this.tablePropList.splice(index, 1) &#125; else &#123; this.tablePropList.push(prop) &#125;&#125; 在mpvue中，page实例获取方式是this.\\$root.mp.page，在vue文件中的this指向vue实例 五、结论现阶段结合自身情况，使用 mpvue + vant 是最合适的方案，vant组件满足不了需求的，需要自己封装业务组件。","categories":[{"name":"前端","slug":"前端","permalink":"http://shangliushuai.cn/categories/前端/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://shangliushuai.cn/tags/小程序/"}]},{"title":"自己封装方法整理","slug":"自己封装方法整理","date":"2018-11-23T16:00:00.000Z","updated":"2019-12-24T00:13:45.597Z","comments":true,"path":"2018/11/24/自己封装方法整理/","link":"","permalink":"http://shangliushuai.cn/2018/11/24/自己封装方法整理/","excerpt":"","text":"这里整理了一些自己封装的方法。 1. 类名12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 通过类名查找元素 * @param strClass 一个或多个类名 * @param context 上下文 范围(可选) 默认是document */function getByClass(strClass, context) &#123; context = context || document; if (document.getElementsByClassName) &#123; return nodeListToArray(context.getElementsByClassName(strClass)); &#125; var aryClass = strClass.match(/\\S+/); var eles = nodeListToArray(context.getElementsByTagName('*')); for (var i = 0; i &lt; aryClass; i++) &#123; var reg = new RegExp('(^| +)' + aryClass[i] + '( +|$)'); for (var j = 0; j &lt; eles.length; j++) &#123; if (!reg.test(eles[i].className)) &#123; eles.splice(j, 1); j--; &#125; &#125; &#125; return eles;&#125;/** * * @param ele 当前元素 * @param strClass 单个类名 * @return true|false */function hasClass(ele, strClass) &#123; var reg = new RegExp(\"(^| +)\" + strClass + \"( +|$)\"); return reg.test(ele.className)&#125;/** * 添加类名 * @param ele 当前的元素 * @param strClass 一个类名或多个类名 */function addClass(ele, strClass) &#123; var aryClass = strClass.replace(/(^\\s+|\\s+$)/g, \"\").split(/\\s+/g); for (var i = 0; i &lt; aryClass.length; i++) &#123; var curClass = aryClass[i]; if (!hasClass(ele, curClass)) &#123; // 若没有这个类名,才添加 ele.className += \" \" + curClass; &#125; &#125;&#125;/** * 删除类名 * @param ele 当前元素 * @param strClass 一个类名或多个类名 */function removeClass(ele, strClass) &#123; //拆分strClass,把每个类名拿到 var aryClass = strClass.replace(/^ +| +$/g, \"\").split(/ +/g); for (var i = 0; i &lt; aryClass.length; i++) &#123; var curClass = aryClass[i]; // 每个类名 // 判断是否有这个类名,若有这个类名,则把这个类名删了 var reg = new RegExp(\"(^| +)\" + curClass + \"( +|$)\", \"g\"); if (hasClass(ele, curClass)) &#123; ele.className = ele.className.replace(reg, \" \"); &#125; &#125;&#125; 2. CSS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 获取任意css样式 * @param ele 当前元素 * @param attr css属性 */function getCss(ele, attr) &#123; var res = null; if (typeof getComputedStyle == \"function\") &#123; res = window.getComputedStyle(ele, null)[attr]; &#125; else &#123; if (attr == \"opacity\") &#123; res = ele.currentStyle.filter;//\"alpha(opacity = 50)\" var reg = /^alpha\\(opacity\\s*=\\s*(\\d+(?:\\.\\d+)?)\\)$/; // reg.exec(res)[1] RegExp.$1 res = reg.test(res) ? RegExp.$1 / 100 : 1; &#125; else &#123; res = ele.currentStyle[attr]; &#125; &#125; // 对单位的处理 // 若获取值是-&gt;左边是数值,右边是单位,则把单位去掉并转化成数类型 var reg = /^[+-]?(?:\\d+(?:\\.\\d+)?)(?:px|rem|pt|em)?$/i; return reg.test(res) ? parseFloat(res) : res;&#125;/** * * @param ele 当前元素 * @param attr css属性 * @param value css属性值 */function setCss(ele, attr, value) &#123; // 1.对浮动处理 if (attr == \"float\") &#123; ele.style.cssFloat = value; ele.style.styleFloat = value; return; &#125; // 2.对透明度处理 if (attr == \"opacity\") &#123; ele.style.opacity = value; ele.style.filter = \"alpha(opacity =\" + value * 100 + \")\"; return; &#125; // 3.设置单位-对没有设置单位的添加单位 var reg = /^(?:width|height|((?:margin|padding)?(?:top|bottom|left|right)?))$/i; if (reg.test(attr) &amp;&amp; !isNaN(value)) value = value + 'px'; ele.style[attr] = value;&#125;/** * 批量设置css样式 * @param ele 当前元素 * @param opt 对象类型 -每一项是css属性和css属性值 */function setGroup(ele, opt) &#123; //先检测opt的数据类型 if (Object.prototype.toString.call(opt) !== \"[object Object]\") return; for (var attr in opt) &#123; setCss(ele, attr, opt[attr]); &#125;&#125;/** *通过参数确定是调用哪个方法(getCss,setCss,setGroup) */function css() &#123; var fn = getCss; if (arguments.length === 3) fn = setCss; if (arguments.length === 2 &amp;&amp; typeof arguments[1] === 'object') fn = setCssGroup; return fn.apply(null, arguments);&#125; 3. 标签名1234567891011121314151617181920212223242526/** * 获取到指定标签名的子元素 * @param context 上下文 * @param tagName 标记名 (字符串) */function children(context, tagName) &#123; var ary = []; // 1.先获取所有的子节点 var eles = context.childNodes; for (var i = 0; i &lt; eles.length; i++) &#123; // 2.判断是否元素节点 if (eles[i].nodeType === 1) &#123; // 3.判断tagName是否正确 if (typeof tagName === 'string') &#123; // 把相同标记名的元素放入数组中 if (eles[i].nodeName.toLowerCase() === tagName.toLowerCase()) &#123; ary.push(eles[i]); &#125; &#125; else &#123; // 第二个参数错误 ary.push(eles[i]); &#125; &#125; &#125; return ary;&#125; 4. forEach/Map12345678910111213141516171819202122232425Array.prototype.myForEach = function (callback, context) &#123; //浏览器性能优化 if ([].forEach) &#123; this.forEach(callback, context); return; &#125; //this指的是调用forEach方法的数组 context = context || window; //以后callback运行时改变回调函数的this for (var i = 0; i &lt; this.length; i++) &#123; //this[i]数组的每一项，i指索引，this指的原数组本身 callback.call(context, this[i], i, this); &#125;&#125;;Array.prototype.myMap = function (callback, context) &#123; if ([].map) &#123; return this.map(callback, context) &#125; context = context || window; var ary = []; for (var i = 0; i &lt; this.length; i++) &#123; ary.push(callback.call(context, this[i], i, this)); &#125; return ary;&#125;; 5. NodeList123456789101112131415/** * NodeList转换成数组 * @param nodeList */function nodeListToArray(likeAry) &#123; var ary = []; try &#123; ary = [].slice.call(likeAry); &#125; catch (e) &#123; for (var i = 0; i &lt; likeAry.length; i++) &#123; ary.push(likeAry[i]); &#125; &#125; return ary;&#125; 6. UA检测12345678910111213/** * 检测是否移动端 */function isMoblie () &#123; return /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(navigator.userAgent.toLowerCase())&#125;/** * 检测是否iOS */function isIOS () &#123; return /iphone|ipad|ipod/i.test(navigator.userAgent.toLowerCase())&#125; 7. url12345678910111213/** * 把url的参数转换成对象 */function getQuery () &#123; var res = &#123;&#125;; var search = window.location.search; var temp = search.slice(1).split('&amp;'); temp.forEach(function (item, index) &#123; var query = item.split('='); res[query[0]] = query[1] &#125;) return res&#125; 8. jsonp1234567891011121314151617181920212223242526272829303132333435363738function jsonp(opt)&#123; var handleParams = function (_default, opt) &#123; var obj = &#123;&#125;; for (var key in _default) &#123; if (_default.hasOwnProperty(key)) &#123; obj[key] = opt[key] || _default[key]; &#125; &#125; return obj; &#125;; var _default = &#123; url: '', query: '', callback: '', success: null, error: null, charset: '' &#125;; opt = handleParams(_default, opt); var script = document.createElement(\"script\"), head = document.head; script.src = opt.url + '?' + opt.query; script.setAttribute('type', 'text/javascript'); opt.charset &amp;&amp; script.setAttribute('charset', opt.charset); window[opt.callback] = function (data) &#123; opt.success &amp;&amp; opt.success(data); delete window[opt.callback]; &#125;; script.onerror = function (error) &#123; error &amp;&amp; opt.error(); delete window[opt.callback]; &#125; script.onload = function () &#123; head.removeChild(script); script = null; &#125; head.appendChild(script);&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://shangliushuai.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://shangliushuai.cn/tags/JavaScript/"}]},{"title":"Flat函数","slug":"Flat函数","date":"2018-06-15T16:00:00.000Z","updated":"2019-12-24T00:13:45.597Z","comments":true,"path":"2018/06/16/Flat函数/","link":"","permalink":"http://shangliushuai.cn/2018/06/16/Flat函数/","excerpt":"","text":"经常会遇到需要把数组展开的面试题，比如把数组[&#39;j&#39;,[&#39;a&#39;,&#39;r&#39;],&#39;v&#39;,[&#39;a,&#39;n&#39;],[5,[2,0]]]展开变成[&quot;j&quot;, &quot;a&quot;, &quot;r&quot;, &quot;v&quot;, &quot;a&quot;, &quot;n&quot;, 5, 2, 0]。常见方式肯定是递归，今天发现了一种利用ES6新特性的方式，记录下来张张见识。 先写下比较常见的递归方式： 1234567891011121314let flat1 = (arr) =&gt; &#123; let res = [] let flat = (target) =&gt; &#123; if (target instanceof Array) &#123; target.forEach(item =&gt; &#123; flat(item); &#125;) &#125; else &#123; res.push(target); &#125; &#125; flat(arr); return res&#125;; 接着是利用ES6遍历器的方式： 123456789101112131415161718192021222324252627282930313233let flat2 = (arr) =&gt; &#123; Array.prototype[Symbol.iterator] = function () &#123; let arr = [].concat(this); let getFirst = (array) =&gt; &#123; let first = array.shift(); if (first instanceof Array) &#123; if (first.length &gt; 1) &#123; arr = first.slice(1).concat(array); &#125; first = first[0]; &#125; return first; &#125;; return &#123; next: function () &#123; let item = getFirst(arr); if (item !== undefined) &#123; return &#123; value: item, done: false &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125; &#125; &#125;; &#125;; let res = []; for (let i of arr) &#123; res.push(i); &#125; return res;&#125;; 这种方式就比较惊艳，充分利用ES6新特性，值得好好深入研究，这里就先记录下，待后续深入研究下遍历器。","categories":[{"name":"前端","slug":"前端","permalink":"http://shangliushuai.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://shangliushuai.cn/tags/JavaScript/"},{"name":"面试题","slug":"面试题","permalink":"http://shangliushuai.cn/tags/面试题/"}]},{"title":"数组排序","slug":"数组排序","date":"2018-05-19T16:00:00.000Z","updated":"2019-12-24T00:13:45.596Z","comments":true,"path":"2018/05/20/数组排序/","link":"","permalink":"http://shangliushuai.cn/2018/05/20/数组排序/","excerpt":"","text":"数组排序的几种方法。 冒泡排序123456789101112131415161718192021function bubbleSort(ary) &#123; var flag = false; var temp = null; for (var i = 0; i &lt; ary.length - 1; i++) &#123; for (var j = 0; j &lt; ary.length - 1 - i; j++) &#123; if (ary[j] &gt; ary[j + 1]) &#123; temp = ary[j]; ary[j] = ary[j + 1]; ary[j + 1] = temp; flag = true; &#125; &#125; // 一轮过后没有变化，则已经是结果 if (flag) &#123; flag = false; &#125; else &#123; break; &#125; &#125; return ary;&#125; 插入排序12345678910111213141516171819function insertSort(ary) &#123; var newAry = []; newAry.push(ary[0]); for (var i = 1; i &lt; ary.length; i++) &#123; var cur = ary[i]; for (var j = newAry.length - 1; j &gt;= 0;) &#123; if (cur &lt; newAry[j]) &#123; j--; if (j === -1) &#123; newAry.unshift(cur); &#125; &#125; else &#123; newAry.splice(j + 1, 0, cur); j = -1; &#125; &#125; &#125; return newAry;&#125; 快速排序1234567891011121314function quickSort(ary) &#123; if (ary.length &lt;= 1) &#123; return ary; &#125; var pointIndex = Math.floor(ary.length / 2); var pointValue = ary.splice(pointIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; ary.length; i++) &#123; var cur = ary[i]; cur &lt; pointValue ? left.push(cur) : right.push(cur); &#125; return quickSort(left).concat([pointValue], quickSort(right));&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://shangliushuai.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://shangliushuai.cn/tags/JavaScript/"}]},{"title":"ES5继承","slug":"ES5继承","date":"2018-05-03T16:00:00.000Z","updated":"2019-12-24T00:13:45.596Z","comments":true,"path":"2018/05/04/ES5继承/","link":"","permalink":"http://shangliushuai.cn/2018/05/04/ES5继承/","excerpt":"","text":"面向对象编程有三大特征：封帐、继承、多态。 严格意义上来说，JavaScript是没有继承和多态的，所以需要我们自己来实现，今天来讲讲ES5的继承实现方法。 我个人认为，最好的继承方案，应该是父类私有的属性和方法拿到子类上用，父类公有的属性和方法直接通过__proto__查找到。 要实现父类的私有属性和方法拿到子类上来用，最简单的方式就是用call方法。 1234567891011function Father() &#123; this.x = 10; this.y = 20;&#125;Father.prototype.fn=function () &#123; console.log(this.x);&#125;;function Son() &#123; //this-&gt;实例 Father.call(this); //父类上的私有属性拷贝一份放到子类的实例上&#125; 这样，私有属性和方法的继承就完成了，接下来，我们看怎么继承公有属性和方法。 首先，把父类的prototype直接赋值给子类： 1Son.prototype = Father.prototype; 这样会导致互相污染，肯定是行不通的。接着，能想到的方式肯定是把父类实例化一个实例出来，然后子类的prototype改为这个实例： 1Son.prototype = new Father(); 这样确实子类可以拿到父类的公有属性和方法，但是这个做法会导致子类的实例和原型上都会有父类的私有属性和方法。这个方式明显就不合适了。 为了只拿到公有属性和方法，试试直接简单粗暴的把父类原型上的属性和方法拷贝一份放在子类原型上： 123456function copy(Father, Son) &#123; for(var attr in Father)&#123; Son[attr] = Father[attr]; &#125;&#125;copy(Father.prototype, Son.prototype); 这样就不会对子类的原型造成污染，但是同样有问题：比较占空间，尤其是父类越来越复杂的时候。 这样的话，貌似借助一个临时的空类是一个不错的选择。 1234function Temp () &#123;&#125;Temp.prototype = Father.prototype;Son.prototype = new Temp(); // 将子类的原型变成临时类的实例Son.prototype.constructor = Son; // 最后别忘了把constructor改回来 这样既可以拿到父类的私有方法和属性，子类的原型上也会有父类的公有属性和方法。 最后来整体看下： 123456789101112131415161718function myCreate(obj) &#123; //obj指的是父类的原型 function Temp () &#123;&#125; Temp.prototype = obj; return new Temp;&#125;function Father() &#123; this.x = 10; this.y = 20;&#125;Father.prototype.fn=function () &#123; console.log(this.x);&#125;;function Son() &#123; Father.call(this);&#125;Son.prototype = myCreate(Father.prototype);Son.prototype.constructor = Son; 这样就完成了一个比较不错的继承，其实myCreate方法应该可以看作一个简化的Object.create()方法","categories":[{"name":"前端","slug":"前端","permalink":"http://shangliushuai.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://shangliushuai.cn/tags/JavaScript/"}]},{"title":"CSS垂直居中","slug":"CSS垂直居中","date":"2018-04-14T16:00:00.000Z","updated":"2019-12-24T00:13:45.596Z","comments":true,"path":"2018/04/15/CSS垂直居中/","link":"","permalink":"http://shangliushuai.cn/2018/04/15/CSS垂直居中/","excerpt":"","text":"1. 行内元素123456.parent &#123; height: X; /* X为一个绝对高度 */&#125;.child &#123; line-hight: X;&#125; 2. Table1234567.parent &#123; display: table;&#125;.child &#123; display: table-cell; vertical-align: middle;&#125; 3. 绝对定位（left+height）12345678910.parent &#123; position: releative;&#125;.child &#123; position: absolute; height: X; /* X为一个绝对高度 */ top: 50%; margin-top: -0.5*X&#125; 4. 绝对定位（transform）123456789.parent &#123; position: releative;&#125;.child &#123; position: absolute; top: 50%; transform: translate(0, -50%);&#125; 5. 绝对定位（top+bottom）12345678910.parent &#123; position: releative;&#125;.child &#123; position: absolute; top: 0; bottom: 0; margin: auto 0;&#125; 6. Flex布局1234.parent &#123; display: flex; align-items: center;&#125; 7. Grid布局1234.parent &#123; display: grid; align-items: center;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://shangliushuai.cn/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://shangliushuai.cn/tags/CSS/"}]},{"title":"CSS水平居中","slug":"CSS水平居中","date":"2018-04-06T16:00:00.000Z","updated":"2019-12-24T00:13:45.596Z","comments":true,"path":"2018/04/07/CSS水平居中/","link":"","permalink":"http://shangliushuai.cn/2018/04/07/CSS水平居中/","excerpt":"","text":"1. 行内元素123.parent &#123; text-align: center;&#125; 2. 块级元素123div &#123; margin: 0 auto;&#125; 3. 绝对定位（left+width）12345678910.parent &#123; position: releative;&#125;.child &#123; position: absolute; width: X; /* X为一个绝对宽度 */ left: 50%; margin-right: -0.5*X&#125; 4. 绝对定位（transform）123456789.parent &#123; position: releative;&#125;.child &#123; position: absolute; left: 50%; transform: translate(-50%, 0);&#125; 5. Flex布局1234.parent &#123; display: flex; justify-content: center;&#125; 6. Grid布局1234.parent &#123; display: grid; justify-items: center;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://shangliushuai.cn/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://shangliushuai.cn/tags/CSS/"}]},{"title":"跨域的方式","slug":"跨域的方式","date":"2018-01-27T16:00:00.000Z","updated":"2019-12-24T00:13:45.596Z","comments":true,"path":"2018/01/28/跨域的方式/","link":"","permalink":"http://shangliushuai.cn/2018/01/28/跨域的方式/","excerpt":"","text":"说到跨域就不得不提一个东西——同源策略。 什么是同源策略？同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 同源策略限制以下几种行为： Cookie、LocalStorage 和 IndexDB 无法读取 DOM 和 Js对象无法获得 AJAX 请求不能发送 虽然同源策略提高了安全性，但是业务和开发中总会遇到需要跨域的场景，今天大概记录下常见的跨域方式的原里，具体实现待以后有机会补充。 1. jsonp利用脚本src可以跨域的特性，前端在页面中插入一个script标签，和后端商定好函数名，我们在全局定义这个函数，后端返回执行这个函数的js代码，参数是需要传输的数据。 2. location.hash + iframe利用hash值变化页面不刷新的特性，配合window.onhashchange事件做到跨域传输数据。 3. window.name + iframe利用name值在不同的页面（甚至不同域名）加载后依旧存在的特性，并且可以支持非常长的 name 值（2MB）。 4. postMessagepostMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题： 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的iframe消息传递 上面三个场景的跨域数据传递 postMessage(data, origin)需要和window.addEventListener(&#39;message&#39;, function(){})配合使用 5. WebSocketWebSocket是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。 6. CORS跨域资源共享，可以看作是ajax的升级版。 CORS首先分为简单请求和非简单请求。 只要同时满足以下两大条件，就属于简单请求： （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 简单请求后端需要设置以下属性： Access-Control-Allow-Origin 非简单请求后端需要设置以下属性： Access-Control-Allow-Origin Access-Control-Allow-Credentials Access-Control-Request-Method Access-Control-Allow-Headers 前端需要设置withCredentials 12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 7. Proxynginx或者node.js转发请求做代理。 node.js做代理比较常见的就是vue cli中的proxy设置了，配合hosts方便开发。","categories":[{"name":"前端","slug":"前端","permalink":"http://shangliushuai.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://shangliushuai.cn/tags/JavaScript/"}]},{"title":"三栏布局","slug":"三栏布局","date":"2018-01-19T16:00:00.000Z","updated":"2019-12-24T00:13:45.595Z","comments":true,"path":"2018/01/20/三栏布局/","link":"","permalink":"http://shangliushuai.cn/2018/01/20/三栏布局/","excerpt":"","text":"这几天看到一个面试题： 已知高度，完成一个三栏布局，左侧200px，右侧200px，中间自适应。 题目看起来不难，第一时间能想起来三种方案：Float、Absolute和Flex，后来发现还有两种：Table和Grid，所以来记录下。 首先写下公共的CSS样式： 1234567891011121314151617181920212223242526html * &#123; margin: 0; padding: 0;&#125;.left &#123; background: red; width: 200px;&#125;.center &#123; background: yellow;&#125;.right &#123; background: blue; width: 200px;&#125;.container &#123; min-height: 100px; margin: 20px; width: 100%;&#125;.left-center-right &#123; min-height: 100px;&#125;.left-center-right&gt;div &#123; min-height: 100px;&#125; 下面来写下五种写法： 1. Float兼容性好，但是会影响文档流 123456789101112&lt;section class=\"container float\"&gt; &lt;div class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h2&gt;Float&lt;/h2&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 123456.container.float .left &#123; float: left;&#125;.container.float .right &#123; float: right;&#125; 2. Absolute兼容性好，但是会影响文档流 123456789101112&lt;section class=\"container absolute\"&gt; &lt;div class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h2&gt;Absolute&lt;/h2&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 12345678910111213141516.container.absolute &#123; position: relative;&#125;.container.absolute .left &#123; position: absolute; left: 0;&#125;.container.absolute .center &#123; position: absolute; left: 200px; right: 200px;&#125;.container.absolute .right &#123; position: absolute; right: 0;&#125; 3. Table兼容性好，但是比较老旧，布局比较麻烦，已经很少见 123456789101112&lt;section class=\"container table\"&gt; &lt;div class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h2&gt;Table&lt;/h2&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 12345678910111213.container.table .left-center-right &#123; display: table; width: 100%;&#125;.container.table .left &#123; display: table-cell;&#125;.container.table .center &#123; display: table-cell;&#125;.container.table .right &#123; display: table-cell;&#125; 4. Flex兼容性较好，在移动端很常用，写法简单。 123456789101112&lt;section class=\"container flex\"&gt; &lt;div class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h2&gt;Flex&lt;/h2&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 123456.container.flex .left-center-right &#123; display: flex;&#125;.container.flex .center &#123; flex: 1;&#125; 5. Grid兼容性不是很好，但是写法最为简单。 123456789101112&lt;section class=\"container grid\"&gt; &lt;div class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h2&gt;Grid&lt;/h2&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 12345.container.grid .left-center-right &#123; display: grid; grid-template-rows: 100px; grid-template-columns: 200px 1fr 200px;&#125; 最后，如果题目修改，高度未定的时候，这五种布局还都能成功么？ 经过测试，增加中间div的内容使之超出div的高度 123456789&lt;div class=\"center\"&gt; &lt;h2&gt;Grid&lt;/h2&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt;&lt;/div&gt; 对比下结果： 正常情况： 添加内容后： 可以看出： Table和Flex布局能正常撑开容器高度，未知高度情况下可以考虑这两个方案 Float布局中间div高度变高，超出部分被宽度会和left-center-right一样，文字从最左边开始 Absolute布局会只撑开中间div的高度 Grid容器和div高度不会改变，但是因为grid-template-rows的设定，文字会超出容器","categories":[{"name":"前端","slug":"前端","permalink":"http://shangliushuai.cn/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://shangliushuai.cn/tags/CSS/"},{"name":"面试题","slug":"面试题","permalink":"http://shangliushuai.cn/tags/面试题/"}]},{"title":"Ajax","slug":"Ajax","date":"2017-11-24T16:00:00.000Z","updated":"2019-12-24T00:13:45.594Z","comments":true,"path":"2017/11/25/Ajax/","link":"","permalink":"http://shangliushuai.cn/2017/11/25/Ajax/","excerpt":"","text":"记录下自己封装的Ajax。 Ajax四步骤： 创建一个XHR对象 打开一个链接地址 监听请求状态 发送数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788let ajax = (options) =&gt; &#123; // 将传入的参数和默认值合并 let extend = (_old, _new) =&gt; &#123; let obj = &#123;&#125;; for (let key in _old) &#123; if (!_old.hasOwnProperty(key)) continue; if (!/^(cache|async)$/.test(key)) &#123; obj[key] = _new[key] || _old[key]; &#125; else &#123; obj[key] = key in _new ? _new[key] : _old[key]; &#125; &#125; return obj; &#125;; // 判断请求的url里是否有?，若有说明已有传输的数据，再添加时以&amp;隔开，若没有?则添加? let hasSearch = (url) =&gt; url = url.indexOf('?') &gt; -1 ? '&amp;' : '?'; // 把对象&#123;name:'Ryan',age:20&#125;转个成一个uri格式字符串'name=\"Ryan\"&amp;age=20 let encodeObjURI = (data) =&gt; &#123; let str = ''; for (let key in data) &#123; str += `$&#123;key&#125;=$&#123;encodeURIComponent(data[key])&#125;&amp;`; &#125; str = str.slice(0, str.length - 1); return str; &#125;; let _default = &#123; type: 'get', url: null, async: true, cache: true, data: null, dataType: 'text', success: null, error: null &#125;; _default = extend(_default, options); let &#123; type, url, async, cache, data, dataType, success, error &#125; = _default; // 1.创建ajax对象 let xhr = new XMLHttpRequest(); // 对get系列方式判断 get|delete|head let regGet = /^(get|delete|head)$/i; // 对post系列方式进行判断 let regPost = /^(post|put)$/i; if (!regGet.test(type) &amp;&amp; !regPost.test(type)) return; // 数据存在，则把数据放在url后 if (data) &#123; if (Object.prototype.toString.call(data) === '[object Object]') &#123; data = encodeObjURI((data)); // 对象转换成uri格式字符串 &#125; if (regGet.test(type)) &#123; url += `$&#123;hasSearch(url)&#125;$&#123;data&#125;`; data = null; &#125; &#125; // 处理缓存，若是get方式并且不需要缓存 cache = false if (regGet.test(type) &amp;&amp; cache === false) &#123; url += `$&#123;hasSearch(url)&#125;_=$&#123;Math.random()&#125;`; &#125; // 2.打开一个链接地址 xhr.open(type, url, async); // 3.监听请求 xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; /^2\\d&#123;2&#125;$/.test(xhr.status)) &#123; let result = xhr.responseText; switch (dataType) &#123; case 'json': result = 'JSON' in window ? JSON.parse(result) : eval('(' + result + ')'); break; case 'xml': result = xhr.responseXML; break; &#125; success &amp;&amp; success(result); &#125; if (xhr.readyState === 4 &amp;&amp; /^(4|5)\\d&#123;2&#125;$/.test(xhr.status)) &#123; error &amp;&amp; error(xhr); &#125; &#125;; // 4.发送数据 xhr.send(data); // 只能是字符串，get方式为null，post方式才把数据放在请求体里&#125;;","categories":[{"name":"前端","slug":"前端","permalink":"http://shangliushuai.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://shangliushuai.cn/tags/JavaScript/"}]},{"title":"Ubuntu16.04和Win10双系统时间错乱修复","slug":"Ubuntu16-04和Win10双系统时间错乱修复","date":"2017-10-21T16:00:00.000Z","updated":"2019-12-24T00:13:45.594Z","comments":true,"path":"2017/10/22/Ubuntu16-04和Win10双系统时间错乱修复/","link":"","permalink":"http://shangliushuai.cn/2017/10/22/Ubuntu16-04和Win10双系统时间错乱修复/","excerpt":"","text":"首先进入Ubuntu更新时间。12$ sudo apt-get install ntpdata$ sudo ntpdate time.windows.com 然后将时间更新到硬件中。1$ sudo hwclock --localttime --systohc 重新进入Win10，查看时间是否正常。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://shangliushuai.cn/categories/Linux/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://shangliushuai.cn/tags/Ubuntu/"}]},{"title":"Chromebook利用Crouton安装Ubuntu卡google解决办法","slug":"Chromebook利用Crouton安装Ubuntu卡google解决办法","date":"2017-10-21T16:00:00.000Z","updated":"2019-12-24T00:13:45.593Z","comments":true,"path":"2017/10/22/Chromebook利用Crouton安装Ubuntu卡google解决办法/","link":"","permalink":"http://shangliushuai.cn/2017/10/22/Chromebook利用Crouton安装Ubuntu卡google解决办法/","excerpt":"","text":"利用crouton自带参数更改软件源 1$ sudo sh ~/Downloads/crouton -r xenial -m http://mirror.163.com/ubuntu -t core,audio,keyborad,touch,xfce-desktop","categories":[{"name":"Linux","slug":"Linux","permalink":"http://shangliushuai.cn/categories/Linux/"}],"tags":[{"name":"Chromebook","slug":"Chromebook","permalink":"http://shangliushuai.cn/tags/Chromebook/"}]},{"title":"Adblock Plus检测","slug":"Adblock Plus检测","date":"2017-09-16T16:00:00.000Z","updated":"2019-12-24T00:13:45.593Z","comments":true,"path":"2017/09/17/Adblock Plus检测/","link":"","permalink":"http://shangliushuai.cn/2017/09/17/Adblock Plus检测/","excerpt":"","text":"​ Adblock Plus是现在很多用户会安装的一些浏览器扩展插件，用来屏蔽使用浏览器浏览时页面中的插件。 ​ 最近在写一个静态页面时，发现有张图片加载不出来，图片名为ad.jpg，调试了之后发现是浏览器的Adblock Plus把这张图片屏蔽掉了。 ​ 刚开始没在意，后来浏览知乎和cnBeta时，发现都有因为使用Adblock Plus出现的提示，就突然很好奇，Adblock Plus检测是怎么实现的，自己根据写项目时的情况，实现了下检测Adblock Plus的功能。 要解决的问题： ​ 在不影响页面布局的情况下，检测用户是否使用Adblock Plus插件。 主要代码如下： 12345678let testAdblock = () =&gt; &#123; let img = new Image(); img.src = 'img/ad.jpg'; //img.src = 'images/ad.jpg'; img.onerror = function () &#123; alert('您使用了Adblock插件'); &#125;;&#125;; 大体思路如下： 创建一个图片对象 给这个图片对象添加一个路径属性src 通过图片的onerror事件检测图片是否成功加载 ​ 创建一个图片对象是为了不更改界面布局，添加src属性后，如果图片被插件屏蔽，是无法加载成功的。 需要改进的地方： 需要增加一次请求，需要考虑是否可以用其他资源代替 没有检测图片资源是否能访问到，有可能onerror事件触发是因为资源获取不到 onerror是个事件，事件函数处理过程是异步的，所以如果真的投入生产工作中，还需要进一步完善 很有意思的一点，不知道是不是Adblock Plus规则问题，我的Adblock Plus插件屏蔽规则是EasyList China+EasyList。在试验过程中，图片必须放在img文件夹或者images文件夹中，就像代码中的那两种。放在根目录和image文件夹中都无法触发Adblock Plus的屏蔽功能 ​ 这次也就是大体上思考并且动手实践了一下，很多细节都没有去处理，以后还会在继续研究一下。","categories":[{"name":"前端","slug":"前端","permalink":"http://shangliushuai.cn/categories/前端/"}],"tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"http://shangliushuai.cn/tags/杂七杂八/"}]},{"title":"console.log()是同步还是异步？","slug":"console.log是同步还是异步","date":"2017-08-26T16:00:00.000Z","updated":"2019-12-24T00:13:45.592Z","comments":true,"path":"2017/08/27/console.log是同步还是异步/","link":"","permalink":"http://shangliushuai.cn/2017/08/27/console.log是同步还是异步/","excerpt":"","text":"​ 最近在研究对象深拷贝的时候无意间发现了这样一个现象： 1234let obj = &#123;name: 'Ryan',info:&#123;name:'Ryan'&#125;&#125;;console.log(obj);obj.info.name = 'Shang';console.log(obj); ​ 在html中写上这段代码，在chrome浏览器中执行的结果是这样： ​ obj.info.name的值竟然在第一次打印的时候就变了？难不成console.log是一个异步操作？ ​ 接着我在node环境中试验了一下： ​ 结果正常。 ​ 继续测试，我更改了下代码： 1234let obj = &#123;name: 'Ryan',info:&#123;name:'Ryan'&#125;&#125;;console.log(JSON.stringify(obj));obj.info.name = 'Shang';console.log(JSON.stringify(obj)); ​ 结果是这样： ​ 这样更疑惑了。 ​ 代码在node环境中运行和在字符串化后都正常。那么可能就是Chrome控制台的一个bug？ ​ 在Google上搜寻了相关内容，结果比较有意思。 ​ Chrome的控制台在处理对象时，有可能保存的是对象的引用地址。控制台对于引用地址的对象属性变化的更新可能是比较懒的，可能当你需要使用这个对象或对其进行操作时，它才会更新。所以，当你直接打印对象时，显示的是最近的状态，但你对obj进行操作后，显示的值就会更新为正确的值。 ​ 大概就是这个原因导致文中的情况，不过究竟如何，还需要深入研究，可能我现在的思考结果也不一定对。 参考资料： https://stackoverflow.com/questions/23392111/console-log-async-or-sync https://stackoverflow.com/questions/4057440/is-chromes-javascript-console-lazy-about-evaluating-arrays","categories":[{"name":"前端","slug":"前端","permalink":"http://shangliushuai.cn/categories/前端/"}],"tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"http://shangliushuai.cn/tags/杂七杂八/"}]},{"title":"Vue.js学习笔记","slug":"Vue.js学习笔记","date":"2017-08-19T16:00:00.000Z","updated":"2019-12-24T00:13:45.592Z","comments":true,"path":"2017/08/20/Vue.js学习笔记/","link":"","permalink":"http://shangliushuai.cn/2017/08/20/Vue.js学习笔记/","excerpt":"","text":"库和框架库 别人写好的内容由我们主动调用 常见库：jQuery Underscore Zepto Animate.css 框架 拥有完整的解决方案，我们写好内容交给框架调用 常见框架：vue angular react backbone 架构模式MVC模式 单项数据绑定 backbone Model 模型 View 视图 Controller 控制器 MVVM模式 双向数据绑定 vue，angular Model 模型 View 视图 ViewModel 视图模型 vuevue的优点 只关注视图层，不需要操作DOM 轻量级，压缩后只有不到20k 渐进式框架，根据需求选择 vue的兼容性​ Vue.js 不支持 IE8 及其以下版本，因为 Vue.js 使用了 IE8 不能模拟的 ECMAScript 5 特性。 vue的安装12# 最新稳定版$ npm install vue { { } }​ { { } }取值表达式，通过{ { } }来进行取值，默认可以不写this，支持表达式、赋值运算、计算和三元表达式 。尽量少写逻辑运算（computed） 指令 v-开头的行内属性 v-model 实现双向数据绑定（看到表单元素加v-model）,忽略掉value，checked，selected，将数据绑定的视图上，视图修改后会影响数据的变化。 v-html 把html字符串渲染成html标签 v-text 把数据渲染成文本，{ { } }是v-text简写写法 v-for 循环（数组，对象，字符串，数字） v-on 事件 v-on:click-&gt;@click 绑定给DOM元素，函数需要定义在methods中，不能和data中的内容重名，this指向实例，不能使用箭头函数，事件源对象如果不写括号，可以自动传入，否则只能手动传入$event 修饰符 .number数字 .lazy离开修饰符 按键修饰符 .enter .ctrl .keyCode 事件相关 @事件.stop stopPropagation,cancelBubble=trued 阻止事件传播 @事件.capture xxx.addEventLister(‘click’,fn,true) @事件.prevent preventDefault,returnValue=false @事件.once jQuery once; on ‘click’ off ‘click’ @事件.self e.srcElement&amp;&amp;e.target 判断事件源绑定事件 v-if 操作DOM v-else-if 操作DOM v-else 操作DOM v-show 样式上的显示和隐藏 频繁的控制显示和隐藏 v-once 数据只渲染一次，数据再变化是不会导致视图刷新 v-cloak 相应比较慢的时候，会看到{ { } }，出现闪烁的效果，防止闪烁效果出现 v-bind 动态绑定属性 123456789101112&lt;div id=\"app\"&gt; &lt;!--:class绑定的样式和class绑定的不冲突--&gt; &lt;!--1.&#123;className:isActive&#125;--&gt; &lt;div class=\"x\" :class=\"&#123;z:flag,y:true&#125;\"&gt;啦啦啦&lt;/div&gt; &lt;div class=\"x\" :class=\"['y','z']\"&gt;哈哈哈&lt;/div&gt; &lt;div class=\"x\" :class=\"[class1,&#123;z:true&#125;]\"&gt;呵呵呵&lt;/div&gt; &lt;div class=\"x\" :class=\"&#123;true:'y',false:'z'&#125;[true]\"&gt;不怎么用&lt;/div&gt; &lt;div v-for=\"(a,index) in 10\" :class=\"&#123;x:index%2===0&#125;\"&gt;&#123;&#123;a&#125;&#125;&lt;/div&gt; &lt;!--动态绑定样式--&gt; &lt;div style=\"font-size: 30px;\" :style=\"&#123;backgroundColor:'red',color:'pink'&#125;\"&gt;嘿嘿嘿&lt;/div&gt; &lt;div :style=\"[sty1,sty2,&#123;fontSize:'30px'&#125;]\"&gt;略略略&lt;/div&gt;&lt;/div&gt; 123456789let vm = new Vue(&#123; el:'#app', data:&#123; flag:true, class1:'y', sty1:&#123;backgroundColor:'red'&#125;, sty2:&#123;color:'pink'&#125; &#125;&#125;); data保存变量 1&lt;div id=\"app\"&gt;&#123;&#123;val&#125;&#125;&lt;/div&gt; 123456let vm = new Vue(&#123; el:'#app', data:&#123; val:'Hello world!' &#125;&#125;); methods定义需要执行的使用的函数方法 1&lt;div id=\"app\"&gt;&#123;&#123;'123'| my&#125;&#125;&lt;/div&gt; 12345678let vm = new Vue(&#123; el:'#app', filters:&#123; my(data,param1,param2)&#123; //do something &#125; &#125;&#125;); filters 过滤器对数据的显示效果进行处理 1&lt;div id=\"app\"&gt;&#123;&#123;'123'| my&#125;&#125;&lt;/div&gt; 12345678let vm = new Vue(&#123; el:'#app', filters:&#123; my(data,param1,param2)&#123; //do something &#125; &#125;&#125;); computed 计算“属性”，不是方法计算属性的值，不需要在data中再次声明 1234&lt;div id=\"app\"&gt; 全选&lt;input type=\"checkbox\" v-model=\"checkAll\"&gt;&lt;br&gt; &lt;input type=\"checkbox\" v-for=\"product in products\" v-model=\"product.isSelected\"&gt;&lt;/div&gt; 123456789101112131415161718let vm = new Vue(&#123; el: '#app', data: &#123; products: [&#123;isSelected: true&#125;, &#123;isSelected: true&#125;, &#123;isSelected: true&#125;] &#125;, computed: &#123; checkAll: &#123; get() &#123; return this.products.every(item =&gt; item.isSelected); &#125;, set(val) &#123; //val是给checkAll复制的时候传递过来的 this.products.forEach(item =&gt; &#123; item.isSelected = val; &#125;); &#125; &#125; &#125; &#125;); watch 监测属性变化监测属性变化，属性变化则执行对应方法 1234&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"a\"&gt; &#123;&#123;msg&#125;&#125;&lt;/div&gt; 12345678910111213141516171819202122let vm = new Vue(&#123; el: '#app', data: &#123; a: '', msg: '' &#125;, watch: &#123; //只有值变化时才会触发，支持异步，其他情况我们更善于使用computed a(newVal, oldVal) &#123; //方法名要和观察对象一致 setTimeout(() =&gt; &#123; if (newVal.length &lt; 3) &#123; this.msg = '太少'; return; &#125; if (newVal.length &gt; 6) &#123; this.msg = '太多'; return; &#125; this.msg = ''; &#125;, 1000); &#125; &#125; &#125;); 生命周期：beforeCreate()​ 触发时机：初始化内部方法和生命周期方法后 created()​ 触发时机：注入数据，完成双向数据绑定后 ​ 一般作用：获取ajax，初始化操作 beforeMount()​ 触发时机：挂载实例和编译模板后，要保证有编译的元素才能执行 mounted()​ 触发时机：真实DOM渲染完成 ​ 一般作用：DOM操作 ​ tips：真实DOM的渲染是异步操作，需要等待DOM渲染完成后来获取。如果数据变化后，想获取真实DOM中的内容，需要等待页面渲染完成后再去获取，所有的DOM操作，最好放在nextTick中执行 beforeUpdate()​ 触发时机：页面依赖的数据需要变化时 ​ 一般作用：不用，用watch代替 updated()​ 触发时机：页面依赖的数据变化，虚拟DOM重新渲染后 ​ 一般作用：不用，用watch代替 beforeDestroy()​ 触发时机：实例销毁前，销毁的是监听 ​ 一般作用：清除定时器，清除事件绑定 destroyed()​ 触发时机：实例销毁后 实例常用方法 this.$mount 挂载实例的另一种方法 this.$data 实例上的数据 this.$watch 监控 this.$el 当前el元素 this.$set 后加的属性实现响应式变化 this.$options 实例上的其他属性 this.$refs ref放在DOM上用来获取DOM元素；放在组件上获取的是组件的实例，并不是组件的DOM元素 this.$nextTick 将回调延迟到下次 DOM 更新循环之后执行 组件概念​ vue把一个自定义标签看作一个组件，vue可以赋予自定义标签一些意义 优点 提高开发效率 方便重复利用 便于协同开发 更容易被管理和维护 用途 页面级组件：一个页面是一个组件 基础组件：将可用的部分抽离出来 用法全局组件：可以声明一次在任何地方使用，写插件的时候用全局属性多一点 12345678Vue.component('my-component', &#123; //一个对象可以看成一个组件 template: '&lt;div&gt;Component &#123;&#123;msg&#125;&#125;&lt;/div&gt;', data() &#123; //组件中数据必须是函数类型，返回一个实例作为组件的值 return &#123; msg: 'Test' &#125;; &#125;&#125;); 局部组件：必须告诉这个组件属于哪个实例 ​ 局部组件创建步骤： ​ 1. 创建组件 ​ 2. 注册组件 ​ 3. 引用组件 ​ 组件是相互独立的，不能直接跨作用域，实力也是一个组件，组件中拥有生命周期函数 ​ 子组件不能直接使用父组件的使用（组件之间数据交互） ​ 组件理论上可以无限嵌套 123456789101112131415161718let component = &#123; template: '&lt;div&gt;Component &#123;&#123;msg&#125;&#125;&lt;/div&gt;', data() &#123; return &#123; msg: 'Test' &#125; &#125;&#125;;let vm = new Vue(&#123; el: '#app', data: &#123; msg: 'Test' //子组件获取不到 &#125;, components: &#123; component &#125;&#125;); 命名 组件名不用大写，多个单词用-连接 只要组件名和定义名字相同是可以的（首字母可以大写） html采用短横线隔开命名法，js中采用驼峰命名法 嵌套组件​ 如果要在一个组件中使用另一个组件，先保证使用的组件是真实存在的，在需要引用这个组件的实例上通过components注册这个组件，组件需要在父级的模板中通过标签的形式引入 12345678910111213141516171819202122let grandson = &#123;template: '&lt;div&gt;Grandson&lt;/div&gt;'&#125;;let son = &#123; template: '&lt;div&gt;Son&lt;grandson&gt;&lt;/grandson&gt;&lt;/div&gt;', components: &#123; grandson &#125;&#125;;let parent = &#123; template: '&lt;div&gt;Parent&lt;son&gt;&lt;/son&gt;&lt;/div&gt;', components: &#123; son &#125;&#125;;let vm = new Vue(&#123; el: '#app', data: &#123;&#125;, template:'&lt;parent&gt;&lt;/parent&gt;', components:&#123; parent &#125;&#125;); 组件间数据传输——父传子（props）​ 给子组件上添加一个属性，绑定对应的父组件，然后给子组件中增加props属性，把在子组件上添加的属性写进去。 12345&lt;div id=\"app\"&gt; 父亲：&#123;&#123;money&#125;&#125; &lt;!--当前组件的属性=父级的值--&gt; &lt;child :m=\"money\"&gt;&lt;/child&gt;&lt;!--给儿子加了一个m属性，属性对应的数据是属于父亲的--&gt;&lt;/div&gt; 1234567891011121314151617181920let vm = new Vue(&#123; el: '#app', data: &#123;money: 400&#125;, components: &#123; child: &#123; props: &#123; m: &#123; //校验属性的类型，如果不带冒号，肯定是字符串，:m='1'数字 :m='true'布尔 type: [String, Boolean, Number, Function, Object, Array],// default: 0, //可以给m赋特殊值，如果不传默认会调用default required: true, //此属性是必须传递，但是不能和default同用 validator(val) &#123; return val &gt; 300; //自定义校验器（用的不多） &#125; &#125; //对象的形式可以校验 &#125;,// props:['m'], //this.m=100; 会在当前子组件上声明一个m属性值是父亲的 template: '&lt;div&gt;儿子：&#123;&#123;m&#125;&#125;&lt;/div&gt;' &#125; &#125;&#125;); 组件间数据传输——子传父（emit）​ 父组件绑定好一些事件，子组件触发这个事件，将这个参数传进去，单项数据流，父组件数据刷新，子组件数据刷新 12345&lt;div id=\"app\"&gt; 父亲：&#123;&#123;money&#125;&#125; &lt;!--child.on('child-msg',things)--&gt; &lt;child :m=\"money\" @child-msg=\"things\"&gt;&lt;/child&gt;&lt;/div&gt; 12345678910111213141516171819202122let vm = new Vue(&#123; el: '#app', data: &#123; money: 200 &#125;, methods: &#123; things(val) &#123; this.money = val; &#125; &#125;, components: &#123; child: &#123; props: ['m'], template: '&lt;div&gt;儿子：&#123;&#123;m&#125;&#125; &lt;br/&gt;&lt;button @click=\"getMoney\"&gt;多来点&lt;/button&gt;&lt;/div&gt;', methods: &#123; getMoney() &#123; this.$emit('child-msg', this.m * 2); //触发自己的自定义事件，都让父亲的方法执行 &#125; &#125; &#125; &#125;&#125;); 语法糖： 123456&lt;div id=\"app\"&gt; 父亲：&#123;&#123;money&#125;&#125; &lt;!--&lt;child :m=\"money\" @update:m=\"val =&gt; this.money = val;\"&gt;&lt;/child&gt;--&gt; &lt;child :m.sync=\"money\"&gt;&lt;/child&gt; &lt;!--写的时候还是按照原有的写法即可--&gt;&lt;/div&gt; 1234567891011121314151617let vm = new Vue(&#123; el: '#app', data: &#123; money: 200 &#125;, components: &#123; child: &#123; props: ['m'], template: '&lt;div&gt;儿子：&#123;&#123;m&#125;&#125; &lt;br/&gt;&lt;button @click=\"getMoney\"&gt;多来点&lt;/button&gt;&lt;/div&gt;', methods: &#123; getMoney() &#123; this.$emit('update:m', this.m * 2); &#125; &#125; &#125; &#125;&#125;); 组件间数据传输——兄弟组件（EventBus）​ 通过新建一个vue实例传递事件 1234&lt;div id=\"app\"&gt; &lt;brother1&gt;&lt;/brother1&gt; &lt;brother2&gt;&lt;/brother2&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647let EventBus = new Vue();let brother1 = &#123; template: '&lt;div&gt;&#123;&#123;color&#125;&#125;&lt;button @click=\"change\"&gt;变绿&lt;/button&gt;&lt;/div&gt;', data() &#123; return &#123; color: '绿色', old: '绿色' &#125; &#125;, created() &#123; EventBus.$on('changeRed', val =&gt; &#123; //页面一加载兄弟1，长个耳朵听 this.color = val; &#125;); &#125;, methods: &#123; change() &#123; EventBus.$emit('changeGreen', this.old); &#125; &#125;&#125;;let brother2 = &#123; template: '&lt;div&gt;&#123;&#123;color&#125;&#125;&lt;button @click=\"change\"&gt;变红&lt;/button&gt;&lt;/div&gt;', data() &#123; return &#123; color: '红色', old: '红色' &#125; &#125;, created() &#123; EventBus.$on('changeGreen', val =&gt; &#123; this.color = val; &#125;); &#125;, methods: &#123; change() &#123; EventBus.$emit('changeRed', this.old); &#125; &#125;&#125;;let vm = new Vue(&#123; el: '#app', data: &#123;&#125;, components: &#123; brother1, brother2 &#125;&#125;); 插槽slot​ 插槽slot可以在组件中通过给DOM元素赋slot属性，在模板中使用slot标签配合name属性把slot标签替换为对应slot属性的DOM元素。 1234567891011121314151617181920212223&lt;div id=\"app\"&gt; &lt;!--这里放的内容均属父级当前模板的，只有属性名属于组件的--&gt; &lt;modal&gt; &lt;a href=\"http://www.shangliushuai.cn\"&gt;Ryan&lt;/a&gt; &lt;p slot=\"content\"&gt;亲，确认删除么？&lt;/p&gt; &lt;h1 slot=\"title\" @click=\"fn\"&gt;是否删除？&lt;/h1&gt; &lt;a href=\"http://www.shangliushuai.cn\"&gt;Ryan&lt;/a&gt; &lt;/modal&gt; &lt;!--&lt;modal&gt;&lt;span&gt;是否确认？&lt;/span&gt;&lt;/modal&gt;--&gt; &lt;!--&lt;modal&gt;&lt;/modal&gt;--&gt;&lt;/div&gt;&lt;!--模板中只能有一个根元素--&gt;&lt;!--可以通过元素属性定制模板--&gt;&lt;template id=\"modal\"&gt; &lt;div&gt; &lt;!--slot的作用：定制模板--&gt; &lt;!--slot可以放置一些默认内容，如果传递了内容则替换掉--&gt; &lt;!--如果没有名字的标签默认会放到default中--&gt; &lt;slot name=\"title\"&gt;默认标题&lt;/slot&gt; &lt;slot name=\"content\"&gt;默认内容&lt;/slot&gt; &lt;slot name=\"default\"&gt;这是一个默认标题&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 1234567891011121314let modal=&#123; template:'#modal', //把teplate内容放到html中的template标签中，通过id名关联&#125;;let vm = new Vue(&#123; el:'#app', data:&#123;&#125;, components:&#123; modal &#125;, methods:&#123; fn()&#123;alert(1);&#125; &#125;&#125;); keep-alive​ 一般用作缓存，如果已缓存则不会再执行created、mounted钩子函数 ​ 子组件和父组件同时拥有mounted方法，先走子组件 1234567&lt;div id=\"app\"&gt; &lt;input type=\"radio\" v-model=\"radio\" value=\"home\"&gt;home &lt;input type=\"radio\" v-model=\"radio\" value=\"list\"&gt;list &lt;keep-alive&gt; &lt;component :is=\"radio\"&gt;&lt;/component&gt; &lt;/keep-alive&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031let home=&#123; template:'&lt;div&gt;home&lt;/div&gt;', mounted()&#123; alert('home'); &#125;, beforeDestroy()&#123; alert('销毁'); &#125;&#125;;let list=&#123; template:'&lt;div&gt;list&lt;/div&gt;', mounted()&#123; alert('list'); &#125;, beforeDestroy()&#123; alert('销毁'); &#125;&#125;;let vm = new Vue(&#123; el:'#app', components:&#123; home,list &#125;, data:&#123; radio:home &#125;, mounted()&#123; alert('vm'); &#125;&#125;); router​ 访问不同的路径，返回不同的结果，常用于单页面应用（spa,single page application），单页面应用常用开发模式： hash模式：开发时使用，不会导致404，但是不支持SEO h5的history.pushStatus：上线使用 使用123456&lt;div id=\"app\"&gt; &lt;router-link to=\"/home\" tag=\"button\"&gt;home&lt;/router-link&gt; &lt;router-link to=\"/list\" tag=\"button\"&gt;list&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;!--router-view是一个全局组件，可以直接使用--&gt;&lt;/div&gt; 1234567891011121314151617181920212223let home = &#123; template: '&lt;div&gt;首页&lt;/div&gt;'&#125;;let list = &#123; template: '&lt;div&gt;列表页&lt;/div&gt;'&#125;;let routes = [ //路由的映射表，配置路径和组件的关系 &#123;path: '/home', component: home&#125;, //配置的关系就是页面级组件 &#123;path: '/list', component: list&#125; //路径必须加斜线];let router = new VueRouter(&#123; //引入vue-router自带VueRouter类 //mode:'history', //h5模式 routes, linkActiveClass:'active'&#125;);let vm = new Vue(&#123; el: '#app', router&#125;); 多级路由123456789101112&lt;div id=\"app\"&gt; &lt;router-link to=\"/home\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/detail\"&gt;详情&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;template id=\"detail\"&gt; &lt;div&gt; &lt;router-link to=\"/detail/profile\"&gt;个人信息&lt;/router-link&gt; &lt;router-link to=\"/detail/about\"&gt;关于&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 12345678910111213141516171819202122232425262728293031323334353637383940let home = &#123; template: '&lt;div&gt;home&lt;/div&gt;'&#125;;let detail = &#123; template: '#detail'&#125;;let profile = &#123; template: '&lt;div&gt;profile&lt;/div&gt;'&#125;;let about = &#123; template: '&lt;div&gt;about&lt;/div&gt;'&#125;;let routes = [ &#123; path: '/home', component: home &#125;, &#123; path: '/detail', component: detail, children: [ //child中路径永远不带/，带/表示是1级路由 &#123;path: 'profile', component: profile&#125;, &#123;path: 'about', component: about&#125;, ] &#125;];let router = new VueRouter(&#123; routes&#125;);let vm = new Vue(&#123; el: '#app', data: &#123;&#125;, router&#125;); 路由参数1234567&lt;div id=\"app\"&gt; &lt;!--如果使用对象作为to的属性值，并且使用了参数，必须给路由起名，并通过名字跳转--&gt; &lt;router-link :to=\"&#123;name:'pro',params:&#123;c:1,a:2&#125;&#125;\"&gt;商品1&lt;/router-link&gt; &lt;router-link to=\"/article/2/b\"&gt;商品2&lt;/router-link&gt; &lt;router-link to=\"/article/3/c\"&gt;商品3&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627let article = &#123; template: '&lt;div&gt;第 &#123;&#123;$route.params.c&#125;&#125; 篇文章&lt;/div&gt;', watch: &#123; //路径参数发生变化，通过监控参数变化来发送ajax $route() &#123; //路径每次变化，$route每次重新赋值 alert('发送ajax请求'); &#125; &#125;&#125;;// /article/1/a 匹配出一个对象// /article/:c/:a =&gt; &#123;c:1,a:'a'&#125; = this.$route.paramslet routes = [ &#123; path: '/article/:c/:a', component: article, name: 'pro' &#125;];let router = new VueRouter(&#123; routes&#125;);let vm = new Vue(&#123; el: '#app', data: &#123;&#125;, router&#125;);","categories":[{"name":"前端","slug":"前端","permalink":"http://shangliushuai.cn/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://shangliushuai.cn/tags/Vue/"}]},{"title":"React学习笔记","slug":"React学习笔记","date":"2017-06-15T16:00:00.000Z","updated":"2019-12-24T00:13:45.592Z","comments":true,"path":"2017/06/16/React学习笔记/","link":"","permalink":"http://shangliushuai.cn/2017/06/16/React学习笔记/","excerpt":"","text":"JSX​ JSX是react发明的特殊写法语法，JSX=JavaScript+XML，就是JS和HTML的混合写法，这并不是JS引擎原生支持的，所以想在浏览器中直接执行，需要先转成ES5代码。jsx本质上就是一个js变量，可以作为参数、函数返回值、也可以用在循环/判断语句中。 1234ReactDOM.render( &lt;h1 id=\"msg\"&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;/h1&gt;, document.querySelector('#root')); 转义成为： 123456789101112131415//1参数是元素类型，2参数是属性对象，3参数是子元素ReactDom.render(React.createElement( \"h1\", &#123; id: \"msg\" &#125;, React.createElement( \"span\", null, \"hello\" ), React.createElement( \"span\", null, \"world\" )), document.querySelector('#root')); 原理： 1234567891011121314151617//createElement方法执行后会返回一个虚拟DOM对象function createElement(type, props, children) &#123; return &#123;type, props: &#123;...props, children&#125;&#125;;&#125;//把一个虚拟DOM变成真实DOM并插入容器内部function render(virtualDOM, container) &#123; let ele = document.createElement(virtualDOM.type); for (let attr in virtualDOM.props) &#123; if (attr === 'children') &#123; ele.innerHTML = virtualDOM.props[attr]; &#125; else &#123; ele.setAttribute(attr, virtualDOM.props[attr]); &#125; container.appendChild(ele); &#125;&#125; ReactDom渲染过程： 把jsx元素转成React.createElement方法的调用 createElement会返回一个虚拟DOM对象 render方法负责把虚拟DOM对象转换成真实DOM对象，并插入到容器内部 jsx规则： 如果需要换行的话，需要把jsx放在小括号里 如果想在js中显示js变量，需要放入大括号，里面可以放入js表达式 表达式中不能放对象，可以放字符串、数字等，还可以放函数的调用 jsx react元素的属性： 普通属性 特殊属性 class =&gt; className for =&gt; htmlFor 如果属性名是多个单词的话，驼峰命名法 z-index =&gt; zIndex tab-index =&gt; tabIndex react元素有一个非常重要的属性叫children，指这个元素的所有子元素 jsx设置事件：​ 给react元素设置属性 on+事件名，事件名开头大写。 1&lt;div onClick=&#123;fn&#125;&gt; ref：​ ref的值是一个函数，当这个DOM挂载到页面之后会执行绑定的函数，参数就是此react元素对应的真实DOM元素。 12//当这个input的虚拟DOM转成真实的并插入到页面中后，会调用元素的ref函数，并且把这个真实DOM作为参数传到函数中&lt;input type=\"text\" id=\"username\" required ref=&#123;input =&gt; &#123;console.log(input)&#125;&#125;/&gt; 组件​ 组件就像一个纯函数，接受任意参数，返回一个并且只有一个react元素。声明组件有两种方式：函数组件和类组件。 渲染组件的过程： 初始化属性对象，然后调用类的构造函数，并把类的属性对象传进去，得到组件的实例 会调用实例的render方法，得到返回的react元素 render方法会把react元素渲染成真实的DOM元素，并挂载到容器内部 函数式组件： 1. 接受一个props参数，是一个对象 2. 组件名称必须首字母大写，render只能通过首字母判断是元素还是组件（组件和元素使用方式完全相同，但渲染和使用方式不同，元素之间渲染，组件渲染返回值） 3. 组件函数要返回并且只能返回一个顶级react元素 4. 函数组件没有实例，也没有this 1234567function Welcome(props) &#123; if (props.username) &#123; return &lt;h1&gt;hello &#123;props.username&#125;&lt;/h1&gt; &#125; else &#123; return &lt;h1&gt;hello stranger&lt;/h1&gt; &#125;&#125; 类组件： 必须继承自React.Component 类组件是有实例的，需要通过this来调用属性 传给组件的属性会全部封装到一个对象中作为实参传给组件对象 123456789101112131415161718192021class Welcome extends React.Component &#123; render() &#123; if (this.props.username) &#123; return &lt;h1&gt;hello &#123;this.props.username&#125;&lt;/h1&gt; &#125; else &#123; return &lt;h1&gt;hello stranger&lt;/h1&gt; &#125; &#125;&#125;class App extends React.Component&#123; render()&#123; return ( &lt;div&gt; &lt;Welcome username=\"Ryan\"/&gt; &lt;Welcome username=\"Jarvan\"/&gt; &lt;Welcome username=\"Wen\"/&gt; &lt;/div&gt; ) &#125;&#125; 组件的属性和状态： 组件的属性是由父组件传入的，状态的值时内部初始化的 组件的属性不能修改， 状态的值是可以修改的 组件的值自己不能改，但是父组件可以改 组件的状态是内部初始化的，只能组件内部修改，外部不能修改 组件的属性和状态都是当前组件的数据源 组件的属性是可以自上而下流动的。单项数据流，只能父传子，只能子传父，也不能兄弟之间传递 给组件传入属性对象的一种方式：1ReactDOM.render(&lt;Comment &#123;...comment&#125;/&gt;, document.querySelector('#root')); 组件中循环列表：​ 遍历列表需要给每一项设置key属性 1234567891011121314151617181920const lessons = [ &#123;title: 'Lesson 1: title', description: 'Lesson 1: description'&#125;, &#123;title: 'Lesson 2: title', description: 'Lesson 2: description'&#125;, &#123;title: 'Lesson 3: title', description: 'Lesson 3: description'&#125;, &#123;title: 'Lesson 4: title', description: 'Lesson 4: description'&#125;];class LessonsList extends React.Component &#123; render() &#123; return ( &lt;div&gt; &#123;this.props.lessons.map((item, index) =&gt; &#123; return ( &lt;Lesson lesson=&#123;item&#125; index=&#123;index&#125; key=&#123;index&#125;/&gt; ) &#125;)&#125; &lt;/div&gt; ) &#125;&#125; state​ 组件的状态用来描述组件内部可以变化的数据。组件的状态是类组件所特有的。当类实例化的时候，会自动调用构造函数，我们可以在构造函数中初始化状态对象。 1234567class Clock extends React.Component &#123; constructor(props) &#123; super(props); //super指向父类的构造函数 this.props=props //当一个类继承另一个类时，需要先调用父类的构造函数 this.state = &#123;time: new Date()&#125; &#125;&#125; ​ 修改state需要掉用实例的setState方法，setState方法用来修改状态，传入一个增量对象，会覆盖同名属性或增加新属性，不会删除老的属性。调用setState不但会修改状态，还会重新调用render方法。除了构造函数外，永远不要直接操作state。 ​ 为了提高性能，react可能会把多个setState调用合并成一个。 123componentDidMount() &#123; this.setState(&#123;time: new Date()&#125;); &#125; ​ 注意，setState方法是一个异步方法。 1234567891011this.setState((prevState) =&gt; (&#123;number: prevState.number + 1&#125;));this.setState((prevState) =&gt; (&#123;number: prevState.number + 2&#125;));this.setState((prevState) =&gt; (&#123;number: prevState.number + 3&#125;));//等价于 =&gt;this.setState(&#123;number: this.state.number+1&#125;,()=&gt;&#123; this.setState(&#123;number: this.state.number+2&#125;,()=&gt;&#123; this.setState(&#123;number: this.state.number+3&#125;,()=&gt;&#123; console.log(this.state.number); &#125;); &#125;);&#125;); 兄弟间传递数据——状态提升：​ 要让两个兄弟之间传递数据，需要找到他们最近的共同祖先，然后在共同祖先组件中定义一个特权函数，子孙组件通过这个共同祖先组件的特权方法，可以改变这个共同祖先的state状态。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Input extends React.Component &#123; handleChange(event) &#123; let percent = event.target.value; this.props.setPercent(percent); &#125; render() &#123; //给一个输入框一个value值，会变成只读的 return ( &lt;div&gt; &lt;input type='number' onChange=&#123;this.handleChange.bind(this)&#125; value=&#123;this.props.percent&#125;/&gt; &lt;/div&gt; ) &#125;&#125;class PercentageShower extends React.Component &#123; render() &#123; return ( &lt;div&gt; &#123; (parseFloat(this.props.percent)*100).toFixed(2)+'%' &#125; &lt;/div&gt; ) &#125;&#125;//要让两个兄弟之间传递数据，需要找到他们最近的共同祖先class PercentageApp extends React.Component &#123; constructor() &#123; super(); this.state = &#123;percent: 0.00&#125;; &#125; //定义了一个可以改变父组件中状态对象中percent的方法 setPercent = (percent) =&gt; &#123; this.setState(&#123;percent: percent&#125;); &#125;; render() &#123; return ( &lt;div&gt; &lt;Input percent=&#123;this.state.percent&#125; setPercent=&#123;this.setPercent&#125;/&gt; &lt;PercentageShower percent=&#123;this.state.percent&#125;/&gt; &lt;/div&gt; ) &#125;&#125; 生命周期componentWillReceiveProps: 将要接收属性 componentWillMount: 组件将要挂载 componentDidMount: 组件完成挂载 componentWillUpdate: 组件即将更新 componentDidUpdate: 组件完成更新 componentWillUnmount: 组件即将销毁 shouldComponentUpdate: 询问组件是否更新 12345678shouldComponentUpdate(prevProps, prevState) &#123; console.log('询问组件是否更新'); if (prevState.number &lt; 10) &#123; return true; &#125; else &#123; return false; &#125;&#125; Router​ Router是路由的容器。 开始使用​ 安装react-router-dom 1$ npm install react-router-dom ​ 引入react-router-dom并使用 123456789import &#123;HashRouter as Router,&#125; from 'react-router-dom';//需要使用路由功能的部分需要被Router组件包裹起来ReactDOM.render( &lt;Router&gt; &lt;div&gt; ... &lt;/div&gt; &lt;/Router&gt;, document.querySelector('#root')); Router组件会给他的所有子组件传递三个属性： history 是用来操作历史 goBack 返回上一个路径 push 跳转路径 location 路径 pathname 路径名 state 路径状态 match 匹配上有值，匹配不上为null isExact 是否精确匹配 params 路径参数 path 来自于路由里的path属性 url 来自于url地址中的# 当有路径参数的时候path和url不一样 RouteRoute是路由规则 基本使用使用时，首先使用Link组件实现跳转（类似于Vue中的router-link），然后使用Route组件，通过传入path和component属性，匹配路径默认匹配前缀，只要当前url路径和path的前缀相同就表示能匹配上，然后渲染对应的组件（一组Route类似于Vue中的router-view)。 需要精确匹配，需要给Route组建设置exact属性。 123456789101112131415161718192021import &#123; HashRouter as Router, Route, Link&#125; from 'react-router-dom';//path 路由//component 组件名称ReactDOM.render( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/\"&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/user\"&gt;用户&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/profile\"&gt;个人&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125;/&gt; &lt;Route path=\"/user\" component=&#123;User&#125;/&gt; &lt;Route path=\"/profile\" component=&#123;Profile&#125;/&gt; &lt;/div&gt; &lt;/Router&gt;, document.querySelector('#root')); Link组件中的to属性也可以写作一个对象 123456&lt;Link to=&#123;&#123; pathname: '/courses', search: '?sort=name', hash: '#the-hash', state: &#123; fromDashboard: true &#125;&#125;&#125;/&gt; Switch如果希望最多指向一个组件，则需要把若干个路由由switch包裹起来。 12345&lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125;/&gt; &lt;Route path=\"/user\" component=&#123;User&#125;/&gt; &lt;Route path=\"/login\" component=&#123;Login&#125;/&gt;&lt;/Switch&gt; 路由组件渲染三种方法 component = 组件 1&lt;Route path=\"/\" component=&#123;Home&#125;/&gt; render 是一个函数，返回值是一个组件，路径匹配则渲染 ​ 因为返回的组件不是Router组件的子组件，所以没有Router组件传递过来的三个属性，可用withRouter组件解决，也可直接给返回的组件传入三个属性 1234//rest=&#123;path:\"/profile\"&#125;&lt;Route &#123;...rest&#125; render=&#123;(&#123;location,history,match&#125;) =&gt; ( &lt;Profile history=&#123;history&#125;/&gt; :)&#125;/&gt; children 是一个函数，返回一個React DOM元素，无论匹不匹配都渲染 123&lt;Route path=&#123;to&#125; children=&#123;(&#123;match&#125;) =&gt; ( &lt;li className=&#123;match ? \"active\" : \"\"&#125;&gt;&lt;Link to=&#123;to&#125;&gt;&#123;children&#125;&lt;/Link&gt;&lt;/li&gt;)&#125;/&gt; URL参数在Route中，设置路径参数，在Link组件中直接访问按照需要的路径参数跳转链接即可。 123&lt;Route path=\"/user/detail/:id\" component=&#123;UserDetail&#125;/&gt;&lt;Link to=&#123;&#123;pathname: `/user/detail/$&#123;user.id&#125;`, state: &#123;user&#125;&#125;&#125;&gt;&#123;user.username&#125;&lt;/Link&gt; 认证保护路由受保护路由是指如果当前用户未登录，则不能访问被保护的路由。 原理是利用Route组件的render渲染方式，根据条件判断渲染不同组件。 12345678910111213//ProtectedRoute.jsexport default (&#123;component: Component, ...rest&#125;) =&gt; &#123; return ( &lt;Route &#123;...rest&#125; render=&#123;(&#123;location&#125;) =&gt; ( localStorage.getItem('login') ? &lt;Component/&gt; : &lt;Redirect to=&#123;&#123;pathname: \"/login\", state: &#123;from: location.pathname&#125;&#125;&#125;/&gt; )&#125;/&gt; )&#125;//使用时&lt;ProtectedRoute path=\"/profile\" component=&#123;Profile&#125;/&gt; 自定义链接利用Route组件的children渲染方式，对组件进行操作。 12345678//MenuLink.jsexport default (&#123;to, children,&#125;) =&gt; &#123; return ( &lt;Route exact path=&#123;to&#125; children=&#123;(&#123;match&#125;) =&gt; ( &lt;li className=&#123;match ? \"active\" : \"\"&#125;&gt;&lt;Link to=&#123;to&#125;&gt;&#123;children&#125;&lt;/Link&gt;&lt;/li&gt; )&#125;/&gt;)&#125;; 阻止导航使用Prompt组件，当when属性的值为true的时候，弹出confirm框。 12345import &#123;Prompt&#125; from 'react-router-dom';&lt;Prompt when=&#123;this.state.isEditing&#125; message=&#123;location =&gt; `切换到$&#123;location.pathname&#125;？`&#125;/&gt; 未匹配一般放在路由规则最后，配合Switch组件使用，用于404场景。 1&lt;Route component=&#123;NoMatch&#125;/&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://shangliushuai.cn/categories/前端/"}],"tags":[{"name":"React","slug":"React","permalink":"http://shangliushuai.cn/tags/React/"}]},{"title":"JS中两个等号的比较","slug":"JS中两个等号的比较","date":"2017-06-06T16:00:00.000Z","updated":"2019-12-24T00:13:45.592Z","comments":true,"path":"2017/06/07/JS中两个等号的比较/","link":"","permalink":"http://shangliushuai.cn/2017/06/07/JS中两个等号的比较/","excerpt":"","text":"​ 以前在学习JavaScript时总是有些漏洞，比如JavaScript中两个等号的比较所带来的类型转换问题，今天特别拿出来研究整理了一下。 对象==对象引用类型的数据比较的是引用地址12&#123;&#125;==&#123;&#125;; //false，引用地址不同[]==[]; //false，引用地址不同 对象==字符串对象通过toString()转换成字符串 1234[].toString(); //''(&#123;&#125;).toString(); //[Object Object][]==''; //true(&#123;&#125;)=='abc'; //false 对象==数字对象先通过toString()转换成字符串，字符串再通过Number()转换成数字 1[1]==1; //true [1]=&gt;'1','1'=&gt;1 对象==布尔左右两边先统一转换成数字类型再进行比较 1[]==true; //false []=&gt;0,true=&gt;1 字符串==数字把字符串转换成数字再进行比较 1'abc'==NaN; //false 'abc'=&gt;NaN NaN和NaN不相等 字符串==布尔左右两边先转化成数字再比较 1'1'==true; //true '1'=&gt;1,true=&gt;1 数字==布尔布尔类型转换成数类型再进行比较 1true==3; //false true=&gt;1 NaN==NaNNaN和任何数(包括自己)比较时都返回false 1NaN==NaN; //false null==undefined左右两边不做数据类型转换，返回结果为true 1null==undefined; //true null和undefined没有toString()方法，和任何数去比较，返回结果都为false。和自身比较返回true。 1null==false; //false ​ 按照我的想法，两个等号比较，大致上类型转换的思路是： 对象和对象间比较引用地址 对象和三种基本数据类型转换，先转换成字符串，如果需要则继续转换则数字 三种基本数据类型转换成数字再进行比较 null和undefined和除了自身任何数比较都为false NaN任何时候比较都返回false ​ JavaScript中的这种隐式数据类型转换，有些时候确实会带来一些问题。为了减少这些问题对代码产生影响，我决定尽量少用相等，多用全等以便去更好的控制数据类型。","categories":[{"name":"前端","slug":"前端","permalink":"http://shangliushuai.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://shangliushuai.cn/tags/JavaScript/"}]},{"title":"mongoose中关于user表的问题","slug":"mongoose中关于user表的问题","date":"2017-05-06T16:00:00.000Z","updated":"2019-12-24T00:13:45.592Z","comments":true,"path":"2017/05/07/mongoose中关于user表的问题/","link":"","permalink":"http://shangliushuai.cn/2017/05/07/mongoose中关于user表的问题/","excerpt":"","text":"​ 最近在做毕业设计，后台采用Node.js+Express，数据库采用MongoDB，连接数据库采用的Mongoose中间件。 ​ 在连接数据库时出现了这样一个问题，按照我的需要，数据库中有一个数据集合用来储存用户信息，表名为user。后来发现无论如何都获取不到user集合中的数据，在MondoDB的控制台程序中也获取不到。 ​ 最后安装了RoboMongo这个MongoDB可视化工具才发现，数据库中user数据的名字变成了users，user数据集是个空数据集。 ​ 这应该算是Mongoose插件的一个bug吧。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://shangliushuai.cn/categories/数据库/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://shangliushuai.cn/tags/MongoDB/"}]}]}